"""
Automated Vulnerability Scanner for ACGS-PGP

This module implements automated vulnerability scanning with CI/CD integration
and comprehensive security assessment capabilities.
"""

import json
import logging
import subprocess
import time
from datetime import UTC, datetime

from .adversarial_framework import (
    AdversarialTestConfig,
    AttackCategory,
    VulnerabilityResult,
    VulnerabilitySeverity,
)

logger = logging.getLogger(__name__)


class AutomatedVulnerabilityScanner:
    """
    Automated vulnerability scanner with CI/CD integration.

    This scanner implements:
    - Static code analysis
    - Dynamic security testing
    - Dependency vulnerability scanning
    - Configuration security assessment
    """

    def __init__(self, config: AdversarialTestConfig):
        self.config = config
        self.scan_types = [
            "static_code_analysis",
            "dynamic_security_testing",
            "dependency_vulnerability_scan",
            "configuration_security_assessment",
            "container_security_scan",
            "network_security_scan",
            "api_security_scan",
            "authentication_security_scan",
        ]

        # Security scanning tools configuration
        self.scanning_tools = {
            "bandit": {
                "command": ["bandit", "-r", "src/", "-f", "json"],
                "description": "Python security linter",
            },
            "safety": {
                "command": ["safety", "check", "--json"],
                "description": "Python dependency vulnerability scanner",
            },
            "semgrep": {
                "command": ["semgrep", "--config=auto", "--json", "src/"],
                "description": "Static analysis security scanner",
            },
            "trivy": {
                "command": ["trivy", "fs", "--format", "json", "."],
                "description": "Container and filesystem vulnerability scanner",
            },
        }

    async def run_tests(
        self, available_services: list[str], service_endpoints: dict[str, str]
    ) -> list[VulnerabilityResult]:
        """Run automated vulnerability scanning tests."""
        vulnerabilities = []

        # Run each scan type
        for scan_type in self.scan_types:
            logger.debug(f"Running automated vulnerability scan: {scan_type}")

            try:
                scan_results = await self._run_scan_type(
                    scan_type, available_services, service_endpoints
                )
                vulnerabilities.extend(scan_results)

            except Exception as e:
                logger.error(f"Error running {scan_type}: {e}")

        logger.info(
            f"Automated vulnerability scanning completed - {len(vulnerabilities)} vulnerabilities found"
        )
        return vulnerabilities

    async def _run_scan_type(
        self,
        scan_type: str,
        available_services: list[str],
        service_endpoints: dict[str, str],
    ) -> list[VulnerabilityResult]:
        """Run a specific type of vulnerability scan."""

        if scan_type == "static_code_analysis":
            return await self._run_static_code_analysis()
        elif scan_type == "dynamic_security_testing":
            return await self._run_dynamic_security_testing(
                available_services, service_endpoints
            )
        elif scan_type == "dependency_vulnerability_scan":
            return await self._run_dependency_vulnerability_scan()
        elif scan_type == "configuration_security_assessment":
            return await self._run_configuration_security_assessment()
        elif scan_type == "container_security_scan":
            return await self._run_container_security_scan()
        elif scan_type == "network_security_scan":
            return await self._run_network_security_scan(
                available_services, service_endpoints
            )
        elif scan_type == "api_security_scan":
            return await self._run_api_security_scan(
                available_services, service_endpoints
            )
        elif scan_type == "authentication_security_scan":
            return await self._run_authentication_security_scan(
                available_services, service_endpoints
            )
        else:
            return []

    async def _run_static_code_analysis(self) -> list[VulnerabilityResult]:
        """Run static code analysis security scanning."""
        vulnerabilities = []
        start_time = time.time()

        # Run Bandit security linter
        bandit_results = await self._run_security_tool("bandit")
        if bandit_results:
            vulnerabilities.extend(
                self._parse_bandit_results(bandit_results, start_time)
            )

        # Run Semgrep static analysis
        semgrep_results = await self._run_security_tool("semgrep")
        if semgrep_results:
            vulnerabilities.extend(
                self._parse_semgrep_results(semgrep_results, start_time)
            )

        return vulnerabilities

    async def _run_dependency_vulnerability_scan(self) -> list[VulnerabilityResult]:
        """Run dependency vulnerability scanning."""
        vulnerabilities = []
        start_time = time.time()

        # Run Safety dependency scanner
        safety_results = await self._run_security_tool("safety")
        if safety_results:
            vulnerabilities.extend(
                self._parse_safety_results(safety_results, start_time)
            )

        # Run Trivy filesystem scanner
        trivy_results = await self._run_security_tool("trivy")
        if trivy_results:
            vulnerabilities.extend(self._parse_trivy_results(trivy_results, start_time))

        return vulnerabilities

    async def _run_security_tool(self, tool_name: str) -> dict | None:
        """Run a specific security scanning tool."""
        if tool_name not in self.scanning_tools:
            logger.warning(f"Security tool {tool_name} not configured")
            return None

        tool_config = self.scanning_tools[tool_name]

        try:
            # Run the security tool
            result = subprocess.run(
                tool_config["command"],
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout
            )

            if result.returncode == 0 and result.stdout:
                return json.loads(result.stdout)
            else:
                logger.warning(f"Security tool {tool_name} failed: {result.stderr}")
                return None

        except subprocess.TimeoutExpired:
            logger.error(f"Security tool {tool_name} timed out")
            return None
        except json.JSONDecodeError:
            logger.error(f"Failed to parse {tool_name} output as JSON")
            return None
        except FileNotFoundError:
            logger.warning(f"Security tool {tool_name} not found - skipping")
            return None
        except Exception as e:
            logger.error(f"Error running security tool {tool_name}: {e}")
            return None

    def _parse_bandit_results(
        self, results: dict, start_time: float
    ) -> list[VulnerabilityResult]:
        """Parse Bandit security linter results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000

        for issue in results.get("results", []):
            severity = self._map_bandit_severity(issue.get("issue_severity", "LOW"))

            vulnerabilities.append(
                VulnerabilityResult(
                    test_id=f"bandit_{issue.get('test_id', 'unknown')}_{len(vulnerabilities)}",
                    attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                    severity=severity,
                    service_target="static_analysis",
                    vulnerability_description=f"Bandit security issue: {issue.get('issue_text', 'Unknown')}",
                    attack_vector=f"Static code analysis detected: {issue.get('test_name', 'Unknown test')}",
                    impact_assessment=f"Security vulnerability in {issue.get('filename', 'unknown file')}",
                    proof_of_concept=json.dumps(
                        {
                            "filename": issue.get("filename"),
                            "line_number": issue.get("line_number"),
                            "code": issue.get("code"),
                        }
                    ),
                    mitigation_recommendations=[
                        "Review and fix the identified security issue",
                        "Follow secure coding practices",
                        "Add security testing for this code path",
                    ],
                    cvss_score=self._calculate_bandit_cvss(severity),
                    execution_time_ms=execution_time,
                    timestamp=datetime.now(UTC),
                )
            )

        return vulnerabilities

    def _parse_safety_results(
        self, results: dict, start_time: float
    ) -> list[VulnerabilityResult]:
        """Parse Safety dependency scanner results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000

        for vulnerability in results.get("vulnerabilities", []):
            vulnerabilities.append(
                VulnerabilityResult(
                    test_id=f"safety_{vulnerability.get('id', 'unknown')}",
                    attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                    severity=VulnerabilitySeverity.HIGH,
                    service_target="dependencies",
                    vulnerability_description=f"Dependency vulnerability: {vulnerability.get('advisory', 'Unknown')}",
                    attack_vector=f"Vulnerable dependency: {vulnerability.get('package_name', 'unknown')}",
                    impact_assessment=f"Security vulnerability in dependency {vulnerability.get('package_name')}",
                    proof_of_concept=json.dumps(
                        {
                            "package": vulnerability.get("package_name"),
                            "version": vulnerability.get("analyzed_version"),
                            "vulnerability_id": vulnerability.get("id"),
                        }
                    ),
                    mitigation_recommendations=[
                        f"Update {vulnerability.get('package_name')} to a secure version",
                        "Review dependency security regularly",
                        "Implement dependency scanning in CI/CD",
                    ],
                    cvss_score=7.5,
                    execution_time_ms=execution_time,
                    timestamp=datetime.now(UTC),
                )
            )

        return vulnerabilities

    def _parse_semgrep_results(
        self, results: dict, start_time: float
    ) -> list[VulnerabilityResult]:
        """Parse Semgrep static analysis results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000

        for result in results.get("results", []):
            severity = self._map_semgrep_severity(
                result.get("extra", {}).get("severity", "INFO")
            )

            vulnerabilities.append(
                VulnerabilityResult(
                    test_id=f"semgrep_{result.get('check_id', 'unknown')}_{len(vulnerabilities)}",
                    attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                    severity=severity,
                    service_target="static_analysis",
                    vulnerability_description=f"Semgrep security issue: {result.get('message', 'Unknown')}",
                    attack_vector=f"Static analysis pattern: {result.get('check_id', 'Unknown')}",
                    impact_assessment=f"Security pattern detected in {result.get('path', 'unknown file')}",
                    proof_of_concept=json.dumps(
                        {
                            "path": result.get("path"),
                            "start_line": result.get("start", {}).get("line"),
                            "end_line": result.get("end", {}).get("line"),
                        }
                    ),
                    mitigation_recommendations=[
                        "Review and fix the identified security pattern",
                        "Implement secure coding practices",
                        "Add security code review process",
                    ],
                    cvss_score=self._calculate_semgrep_cvss(severity),
                    execution_time_ms=execution_time,
                    timestamp=datetime.now(UTC),
                )
            )

        return vulnerabilities

    def _parse_trivy_results(
        self, results: dict, start_time: float
    ) -> list[VulnerabilityResult]:
        """Parse Trivy vulnerability scanner results."""
        vulnerabilities = []
        execution_time = (time.time() - start_time) * 1000

        for result in results.get("Results", []):
            for vulnerability in result.get("Vulnerabilities", []):
                severity = self._map_trivy_severity(
                    vulnerability.get("Severity", "UNKNOWN")
                )

                vulnerabilities.append(
                    VulnerabilityResult(
                        test_id=f"trivy_{vulnerability.get('VulnerabilityID', 'unknown')}",
                        attack_category=AttackCategory.CROSS_SERVICE_VULNERABILITY,
                        severity=severity,
                        service_target="filesystem",
                        vulnerability_description=f"Trivy vulnerability: {vulnerability.get('Title', 'Unknown')}",
                        attack_vector=f"Filesystem vulnerability: {vulnerability.get('VulnerabilityID', 'Unknown')}",
                        impact_assessment=f"Security vulnerability in {vulnerability.get('PkgName', 'unknown package')}",
                        proof_of_concept=json.dumps(
                            {
                                "package": vulnerability.get("PkgName"),
                                "version": vulnerability.get("InstalledVersion"),
                                "vulnerability_id": vulnerability.get(
                                    "VulnerabilityID"
                                ),
                            }
                        ),
                        mitigation_recommendations=[
                            f"Update {vulnerability.get('PkgName')} to version {vulnerability.get('FixedVersion', 'latest')}",
                            "Implement container security scanning",
                            "Regular security updates and patching",
                        ],
                        cvss_score=self._calculate_trivy_cvss(severity),
                        execution_time_ms=execution_time,
                        timestamp=datetime.now(UTC),
                    )
                )

        return vulnerabilities

    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Bandit severity to VulnerabilitySeverity."""
        mapping = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)

    def _map_semgrep_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Semgrep severity to VulnerabilitySeverity."""
        mapping = {
            "ERROR": VulnerabilitySeverity.HIGH,
            "WARNING": VulnerabilitySeverity.MEDIUM,
            "INFO": VulnerabilitySeverity.LOW,
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)

    def _map_trivy_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Trivy severity to VulnerabilitySeverity."""
        mapping = {
            "CRITICAL": VulnerabilitySeverity.CRITICAL,
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
            "UNKNOWN": VulnerabilitySeverity.INFO,
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)

    def _calculate_bandit_cvss(self, severity: VulnerabilitySeverity) -> float:
        """Calculate CVSS score for Bandit findings."""
        score_map = {
            VulnerabilitySeverity.HIGH: 7.5,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.LOW: 3.0,
        }
        return score_map.get(severity, 5.0)

    def _calculate_semgrep_cvss(self, severity: VulnerabilitySeverity) -> float:
        """Calculate CVSS score for Semgrep findings."""
        score_map = {
            VulnerabilitySeverity.HIGH: 8.0,
            VulnerabilitySeverity.MEDIUM: 6.0,
            VulnerabilitySeverity.LOW: 4.0,
        }
        return score_map.get(severity, 6.0)

    def _calculate_trivy_cvss(self, severity: VulnerabilitySeverity) -> float:
        """Calculate CVSS score for Trivy findings."""
        score_map = {
            VulnerabilitySeverity.CRITICAL: 9.5,
            VulnerabilitySeverity.HIGH: 8.5,
            VulnerabilitySeverity.MEDIUM: 6.5,
            VulnerabilitySeverity.LOW: 4.0,
            VulnerabilitySeverity.INFO: 2.0,
        }
        return score_map.get(severity, 6.0)

    async def _run_dynamic_security_testing(
        self, available_services: list[str], service_endpoints: dict[str, str]
    ) -> list[VulnerabilityResult]:
        """Run dynamic security testing."""
        # Implementation for dynamic security testing
        return []

    async def _run_configuration_security_assessment(self) -> list[VulnerabilityResult]:
        """Run configuration security assessment."""
        # Implementation for configuration security assessment
        return []

    async def _run_container_security_scan(self) -> list[VulnerabilityResult]:
        """Run container security scanning."""
        # Implementation for container security scanning
        return []

    async def _run_network_security_scan(
        self, available_services: list[str], service_endpoints: dict[str, str]
    ) -> list[VulnerabilityResult]:
        """Run network security scanning."""
        # Implementation for network security scanning
        return []

    async def _run_api_security_scan(
        self, available_services: list[str], service_endpoints: dict[str, str]
    ) -> list[VulnerabilityResult]:
        """Run API security scanning."""
        # Implementation for API security scanning
        return []

    async def _run_authentication_security_scan(
        self, available_services: list[str], service_endpoints: dict[str, str]
    ) -> list[VulnerabilityResult]:
        """Run authentication security scanning."""
        # Implementation for authentication security scanning
        return []
