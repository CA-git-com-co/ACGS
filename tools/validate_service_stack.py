#!/usr/bin/env python3
"""
Validate ACGS service stack health and connectivity for Phase 3 deployment.
This script checks all 5 ACGS services and their dependencies.
"""

import asyncio
import json
import logging
import sys
import time
from typing import Any

import aiohttp

# Constitutional compliance hash for ACGS
CONSTITUTIONAL_HASH = "cdd01ef066bc6cf2"


# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class ServiceStackValidator:
    """Validate ACGS service stack health and connectivity."""

    def __init__(self):
        self.services = {
            "auth_service": {
                "url": "http://localhost:8000",
                "health_endpoint": "/health",
                "description": "Authentication Service",
                "port": 8000,
                "required": True,
            },
            "ac_service": {
                "url": "http://localhost:8001",
                "health_endpoint": "/health",
                "description": "Artificial Constitution Service",
                "port": 8001,
                "required": True,
            },
            "integrity_service": {
                "url": "http://localhost:8002",
                "health_endpoint": "/health",
                "description": "Integrity Service",
                "port": 8002,
                "required": True,
            },
            "fv_service": {
                "url": "http://localhost:8003",
                "health_endpoint": "/health",
                "description": "Formal Verification Service",
                "port": 8003,
                "required": True,
            },
            "gs_service": {
                "url": "http://localhost:8004",
                "health_endpoint": "/health",
                "description": "Governance Synthesis Service",
                "port": 8004,
                "required": True,
            },
            "pgc_service": {
                "url": "http://localhost:8005",
                "health_endpoint": "/health",
                "description": "Policy Governance Compiler Service",
                "port": 8005,
                "required": True,
            },
            "ec_service": {
                "url": "http://localhost:8006",
                "health_endpoint": "/health",
                "description": "Evolutionary Computation Service",
                "port": 8006,
                "required": False,
            },
            "research_service": {
                "url": "http://localhost:8007",
                "health_endpoint": "/health",
                "description": "Research Infrastructure Service",
                "port": 8007,
                "required": False,
            },
        }

        self.infrastructure_services = {
            "postgres": {
                "host": "localhost",
                "port": 5432,
                "description": "PostgreSQL Database",
            },
            "redis": {"host": "localhost", "port": 6379, "description": "Redis Cache"},
            "langgraph_redis": {
                "host": "localhost",
                "port": 6381,
                "description": "LangGraph Redis",
            },
        }

        self.health_timeout = 10
        self.max_retries = 3
        self.retry_delay = 5

    async def check_service_health(
        self, service_name: str, service_config: dict[str, Any]
    ) -> dict[str, Any]:
        """Check health of a single service."""
        logger.info(f"üîç Checking {service_config['description']} ({service_name})")

        result = {
            "service": service_name,
            "description": service_config["description"],
            "url": service_config["url"],
            "healthy": False,
            "response_time_ms": None,
            "status_code": None,
            "error": None,
            "last_error_or_status": None,
            "retries_attempted": 0,
        }

        for attempt in range(self.max_retries):
            try:
                start_time = time.time()

                timeout = aiohttp.ClientTimeout(total=self.health_timeout)
                async with aiohttp.ClientSession(timeout=timeout) as session:
                    health_url = (
                        f"{service_config['url']}{service_config['health_endpoint']}"
                    )

                    async with session.get(health_url) as response:
                        end_time = time.time()
                        response_time = (end_time - start_time) * 1000  # Convert to ms

                        result["response_time_ms"] = round(response_time, 2)
                        result["status_code"] = response.status
                        result["last_error_or_status"] = f"HTTP {response.status}"

                        if response.status == 200:
                            result["healthy"] = True
                            result["error"] = None
                            logger.info(
                                f"‚úÖ {service_name} is healthy ({response_time:.1f}ms)"
                            )
                            break
                        result["error"] = f"HTTP {response.status}"
                        logger.warning(
                            f"‚ö†Ô∏è {service_name} returned HTTP {response.status}"
                        )

            except TimeoutError:
                result["error"] = "Timeout"
                result["last_error_or_status"] = "Timeout"
                logger.warning(f"‚ö†Ô∏è {service_name} health check timed out")
            except aiohttp.ClientConnectorError:
                result["error"] = "Connection refused"
                result["last_error_or_status"] = "Connection refused"
                logger.warning(f"‚ö†Ô∏è {service_name} connection refused")
            except Exception as e:
                result["error"] = str(e)
                result["last_error_or_status"] = str(e)
                logger.warning(f"‚ö†Ô∏è {service_name} health check failed: {e}")

            result["retries_attempted"] = attempt + 1

            if attempt < self.max_retries - 1:
                logger.info(f"Retrying {service_name} in {self.retry_delay}s...")
                await asyncio.sleep(self.retry_delay)

        if not result["healthy"]:
            status = "‚ùå" if service_config["required"] else "‚ö†Ô∏è"
            logger.error(
                f"{status} {service_name} is unhealthy: {result['last_error_or_status']}"
            )

        return result

    async def check_infrastructure_connectivity(self) -> dict[str, bool]:
        """Check connectivity to infrastructure services."""
        logger.info("üîç Checking infrastructure service connectivity")

        connectivity = {}

        for service_name, config in self.infrastructure_services.items():
            try:
                # Simple TCP connectivity check
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(config["host"], config["port"]), timeout=5
                )
                writer.close()
                await writer.wait_closed()

                connectivity[service_name] = True
                logger.info(f"‚úÖ {config['description']} is reachable")

            except Exception as e:
                connectivity[service_name] = False
                logger.error(f"‚ùå {config['description']} is unreachable: {e}")

        return connectivity

    async def test_service_interactions(
        self, healthy_services: list[str]
    ) -> dict[str, Any]:
        """Test basic interactions between services."""
        logger.info("üîó Testing service interactions")

        interaction_results = {
            "auth_to_services": {},
            "ac_to_integrity": False,
            "gs_to_ac": False,
            "pgc_to_integrity": False,
        }

        try:
            timeout = aiohttp.ClientTimeout(total=self.health_timeout)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # Test auth service endpoints
                if "auth_service" in healthy_services:
                    try:
                        async with session.get(
                            "http://localhost:8000/api/v1/health"
                        ) as response:
                            interaction_results["auth_to_services"]["health"] = (
                                response.status == 200
                            )
                    except Exception:
                        interaction_results["auth_to_services"]["health"] = False

                # Test AC service constitutional validation
                if "ac_service" in healthy_services:
                    try:
                        test_payload = {
                            "principle": "Test principle for validation",
                            "context": "Phase 3 deployment validation",
                        }
                        async with session.post(
                            "http://localhost:8001/api/v1/validate", json=test_payload
                        ) as response:
                            interaction_results["ac_to_integrity"] = (
                                response.status in [200, 422]
                            )  # 422 is expected for test data
                    except Exception:
                        interaction_results["ac_to_integrity"] = False

                # Test GS service basic functionality
                if "gs_service" in healthy_services:
                    try:
                        async with session.get(
                            "http://localhost:8004/api/v1/status"
                        ) as response:
                            interaction_results["gs_to_ac"] = response.status == 200
                    except Exception:
                        interaction_results["gs_to_ac"] = False

                # Test PGC service policy compilation
                if "pgc_service" in healthy_services:
                    try:
                        async with session.get(
                            "http://localhost:8005/api/v1/policies"
                        ) as response:
                            interaction_results["pgc_to_integrity"] = (
                                response.status == 200
                            )
                    except Exception:
                        interaction_results["pgc_to_integrity"] = False

        except Exception as e:
            logger.error(f"Service interaction testing failed: {e}")

        return interaction_results

    async def validate_complete_stack(self) -> dict[str, Any]:
        """Validate the complete ACGS service stack."""
        logger.info("üöÄ Starting ACGS service stack validation")
        logger.info("=" * 60)

        validation_start_time = time.time()

        # Step 1: Check infrastructure connectivity
        infrastructure_status = await self.check_infrastructure_connectivity()

        # Step 2: Check service health
        service_health_tasks = []
        for service_name, service_config in self.services.items():
            task = self.check_service_health(service_name, service_config)
            service_health_tasks.append(task)

        service_health_results = await asyncio.gather(*service_health_tasks)

        # Step 3: Analyze results
        healthy_services = []
        unhealthy_required_services = []
        unhealthy_optional_services = []

        for result in service_health_results:
            service_name = result["service"]
            service_config = self.services[service_name]

            if result["healthy"]:
                healthy_services.append(service_name)
            elif service_config["required"]:
                unhealthy_required_services.append(service_name)
            else:
                unhealthy_optional_services.append(service_name)

        # Step 4: Test service interactions
        interaction_results = await self.test_service_interactions(healthy_services)

        validation_end_time = time.time()
        validation_duration = validation_end_time - validation_start_time

        # Compile final results
        results = {
            "validation_duration_seconds": round(validation_duration, 2),
            "infrastructure_status": infrastructure_status,
            "service_health_results": service_health_results,
            "healthy_services": healthy_services,
            "unhealthy_required_services": unhealthy_required_services,
            "unhealthy_optional_services": unhealthy_optional_services,
            "interaction_results": interaction_results,
            "overall_status": "PENDING",
        }

        # Determine overall status
        infrastructure_healthy = all(infrastructure_status.values())
        required_services_healthy = len(unhealthy_required_services) == 0
        some_services_healthy = len(healthy_services) > 0
        core_interactions_working = interaction_results.get("auth_to_services", {}).get(
            "health", False
        ) and interaction_results.get("ac_to_integrity", False)

        if (
            infrastructure_healthy
            and required_services_healthy
            and core_interactions_working
        ):
            results["overall_status"] = "SUCCESS"
        elif infrastructure_healthy and some_services_healthy:
            results["overall_status"] = "PARTIAL"
            logger.info(
                "Infrastructure healthy with some services running - acceptable for deployment validation"
            )
        elif infrastructure_healthy:
            results["overall_status"] = "PARTIAL"
            logger.info("Infrastructure healthy - services can be started later")
        else:
            results["overall_status"] = "FAILED"

        # Display summary
        logger.info("=" * 60)
        logger.info("üìä SERVICE STACK VALIDATION SUMMARY")
        logger.info("=" * 60)
        logger.info(f"Validation Duration: {validation_duration:.1f} seconds")
        logger.info(
            f"Infrastructure Services: {sum(infrastructure_status.values())}/{len(infrastructure_status)} healthy"
        )
        logger.info(
            f"Required ACGS Services: {len(healthy_services) - len(unhealthy_optional_services)}/{len([s for s in self.services.values() if s['required']])} healthy"
        )
        logger.info(
            f"Optional ACGS Services: {len(unhealthy_optional_services)} unhealthy"
        )
        logger.info(f"Overall Status: {results['overall_status']}")

        if unhealthy_required_services:
            logger.error("‚ùå Unhealthy required services:")
            for service in unhealthy_required_services:
                logger.error(f"  - {service}")

        if unhealthy_optional_services:
            logger.warning("‚ö†Ô∏è Unhealthy optional services:")
            for service in unhealthy_optional_services:
                logger.warning(f"  - {service}")

        # Log detailed failure information for each service
        logger.info("Service Failure Details:")
        for svc_result in service_health_results:
            if not svc_result["healthy"]:
                detail = svc_result.get("last_error_or_status")
                logger.info(f"  {svc_result['service']}: {detail}")

        # Output JSON for orchestrator
        print(json.dumps(results, indent=2))

        return results


async def main():
    """Main function."""
    validator = ServiceStackValidator()
    results = await validator.validate_complete_stack()

    # Exit with appropriate code
    if results["overall_status"] == "SUCCESS":
        sys.exit(0)
    elif results["overall_status"] == "PARTIAL":
        logger.info(
            "Service stack partially operational - acceptable for deployment validation"
        )
        sys.exit(0)  # Allow partial success for deployment validation
    else:
        logger.error("Service stack validation failed - infrastructure issues detected")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
