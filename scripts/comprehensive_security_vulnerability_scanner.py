#!/usr/bin/env python3
"""
ACGS-1 Comprehensive Security Vulnerability Scanner

This script implements automated vulnerability scanning across all application components
with focus on the 24 HIGH severity findings and comprehensive security assessment.

Key Features:
- Multi-tool security scanning (Bandit, Safety, npm audit, cargo audit, Semgrep)
- Dependency vulnerability analysis
- Code security analysis
- Infrastructure security checks
- Compliance validation
- Detailed reporting with severity classification
"""

import asyncio
import json
import logging
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("logs/security_vulnerability_scan.log"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)


class SecurityVulnerabilityScanner:
    """Comprehensive security vulnerability scanner for ACGS-1."""

    def __init__(self, project_root: str = "/home/dislove/ACGS-1"):
        self.project_root = Path(project_root)
        self.scan_id = f"security_vuln_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.results = {
            "scan_id": self.scan_id,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "project_root": str(self.project_root),
            "scans": {},
            "summary": {
                "critical_findings": 0,
                "high_findings": 0,
                "medium_findings": 0,
                "low_findings": 0,
                "total_findings": 0,
            },
            "compliance_status": "UNKNOWN",
            "recommendations": [],
        }

        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        os.makedirs("reports/security", exist_ok=True)

    async def run_comprehensive_scan(self) -> dict[str, Any]:
        """Run comprehensive security vulnerability scan."""
        logger.info(
            f"üîç Starting comprehensive security vulnerability scan: {self.scan_id}"
        )

        # Define scan tasks
        scan_tasks = [
            ("python_bandit", self._run_bandit_scan),
            ("python_safety", self._run_safety_scan),
            ("python_pip_audit", self._run_pip_audit_scan),
            ("javascript_npm_audit", self._run_npm_audit_scan),
            ("rust_cargo_audit", self._run_cargo_audit_scan),
            ("semgrep_sast", self._run_semgrep_scan),
            ("dependency_check", self._run_dependency_check),
            ("secrets_detection", self._run_secrets_detection),
            ("infrastructure_scan", self._run_infrastructure_scan),
            ("service_security_check", self._run_service_security_check),
        ]

        # Execute scans concurrently
        for scan_name, scan_func in scan_tasks:
            try:
                logger.info(f"üîç Running {scan_name} scan...")
                result = await scan_func()
                self.results["scans"][scan_name] = result
                self._update_summary(result)
                logger.info(f"‚úÖ {scan_name} scan completed")
            except Exception as e:
                logger.error(f"‚ùå {scan_name} scan failed: {e}")
                self.results["scans"][scan_name] = {
                    "status": "FAILED",
                    "error": str(e),
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }

        # Generate compliance assessment
        self._assess_compliance()

        # Generate recommendations
        self._generate_recommendations()

        # Save results
        await self._save_results()

        logger.info(f"üéØ Security vulnerability scan completed: {self.scan_id}")
        return self.results

    async def _run_bandit_scan(self) -> dict[str, Any]:
        """Run Bandit security scan for Python code."""
        try:
            cmd = [
                "bandit",
                "-r",
                ".",
                "-f",
                "json",
                "-o",
                f"logs/{self.scan_id}_bandit.json",
                "--exclude",
                "./venv,./node_modules,./target,./blockchain/target",
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=self.project_root,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # Parse results
            result_file = f"logs/{self.scan_id}_bandit.json"
            if os.path.exists(result_file):
                with open(result_file) as f:
                    bandit_results = json.load(f)

                findings = []
                for result in bandit_results.get("results", []):
                    findings.append(
                        {
                            "file": result.get("filename"),
                            "line": result.get("line_number"),
                            "severity": result.get("issue_severity", "UNKNOWN").upper(),
                            "confidence": result.get(
                                "issue_confidence", "UNKNOWN"
                            ).upper(),
                            "test_id": result.get("test_id"),
                            "test_name": result.get("test_name"),
                            "issue_text": result.get("issue_text"),
                            "code": result.get("code"),
                        }
                    )

                return {
                    "status": "SUCCESS",
                    "tool": "bandit",
                    "findings_count": len(findings),
                    "findings": findings,
                    "metrics": bandit_results.get("metrics", {}),
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                }
            return {
                "status": "NO_RESULTS",
                "tool": "bandit",
                "message": "No results file generated",
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "bandit",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_safety_scan(self) -> dict[str, Any]:
        """Run Safety scan for Python dependencies."""
        try:
            cmd = [
                "safety",
                "check",
                "--json",
                "--output",
                f"logs/{self.scan_id}_safety.json",
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=self.project_root,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # Parse results
            result_file = f"logs/{self.scan_id}_safety.json"
            findings = []

            if os.path.exists(result_file):
                with open(result_file) as f:
                    safety_results = json.load(f)

                for vuln in safety_results:
                    findings.append(
                        {
                            "package": vuln.get("package_name"),
                            "version": vuln.get("analyzed_version"),
                            "vulnerability_id": vuln.get("vulnerability_id"),
                            "advisory": vuln.get("advisory"),
                            "severity": "HIGH",  # Safety typically reports high-severity issues
                            "cve": vuln.get("cve"),
                        }
                    )

            return {
                "status": "SUCCESS",
                "tool": "safety",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "safety",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_pip_audit_scan(self) -> dict[str, Any]:
        """Run pip-audit scan for Python dependencies."""
        try:
            cmd = [
                "pip-audit",
                "--format=json",
                "--output",
                f"logs/{self.scan_id}_pip_audit.json",
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=self.project_root,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # Parse results
            result_file = f"logs/{self.scan_id}_pip_audit.json"
            findings = []

            if os.path.exists(result_file):
                with open(result_file) as f:
                    audit_results = json.load(f)

                for vuln in audit_results.get("vulnerabilities", []):
                    findings.append(
                        {
                            "package": vuln.get("package"),
                            "version": vuln.get("version"),
                            "vulnerability_id": vuln.get("id"),
                            "description": vuln.get("description"),
                            "severity": "HIGH",  # Default to HIGH for pip-audit findings
                            "fix_versions": vuln.get("fix_versions", []),
                        }
                    )

            return {
                "status": "SUCCESS",
                "tool": "pip-audit",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "pip-audit",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_npm_audit_scan(self) -> dict[str, Any]:
        """Run npm audit scan for JavaScript dependencies."""
        try:
            # Check for package.json files
            package_json_files = list(self.project_root.rglob("package.json"))
            all_findings = []

            for package_file in package_json_files:
                if "node_modules" in str(package_file):
                    continue

                package_dir = package_file.parent
                cmd = ["npm", "audit", "--json"]

                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    cwd=package_dir,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )

                stdout, stderr = await process.communicate()

                if stdout:
                    try:
                        audit_results = json.loads(stdout.decode())

                        for vuln_id, vuln in audit_results.get(
                            "vulnerabilities", {}
                        ).items():
                            all_findings.append(
                                {
                                    "package": vuln.get("name"),
                                    "severity": vuln.get("severity", "UNKNOWN").upper(),
                                    "vulnerability_id": vuln_id,
                                    "title": vuln.get("title"),
                                    "url": vuln.get("url"),
                                    "package_file": str(
                                        package_file.relative_to(self.project_root)
                                    ),
                                }
                            )
                    except json.JSONDecodeError:
                        continue

            return {
                "status": "SUCCESS",
                "tool": "npm-audit",
                "findings_count": len(all_findings),
                "findings": all_findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "npm-audit",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_cargo_audit_scan(self) -> dict[str, Any]:
        """Run cargo audit scan for Rust dependencies."""
        try:
            # Check for Cargo.toml files
            cargo_files = list(self.project_root.rglob("Cargo.toml"))
            all_findings = []

            for cargo_file in cargo_files:
                if "target" in str(cargo_file):
                    continue

                cargo_dir = cargo_file.parent
                cmd = ["cargo", "audit", "--json"]

                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    cwd=cargo_dir,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )

                stdout, stderr = await process.communicate()

                if stdout:
                    try:
                        for line in stdout.decode().strip().split("\n"):
                            if line.strip():
                                audit_result = json.loads(line)

                                if audit_result.get("type") == "vulnerability":
                                    vuln = audit_result.get("vulnerability", {})
                                    all_findings.append(
                                        {
                                            "package": vuln.get("package"),
                                            "version": vuln.get("patched_versions"),
                                            "vulnerability_id": vuln.get("id"),
                                            "title": vuln.get("title"),
                                            "description": vuln.get("description"),
                                            "severity": "HIGH",  # Default to HIGH for cargo audit
                                            "cargo_file": str(
                                                cargo_file.relative_to(
                                                    self.project_root
                                                )
                                            ),
                                        }
                                    )
                    except json.JSONDecodeError:
                        continue

            return {
                "status": "SUCCESS",
                "tool": "cargo-audit",
                "findings_count": len(all_findings),
                "findings": all_findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "cargo-audit",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_semgrep_scan(self) -> dict[str, Any]:
        """Run Semgrep SAST scan."""
        try:
            cmd = [
                "semgrep",
                "--config=auto",
                "--json",
                "--output",
                f"logs/{self.scan_id}_semgrep.json",
                ".",
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=self.project_root,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # Parse results
            result_file = f"logs/{self.scan_id}_semgrep.json"
            findings = []

            if os.path.exists(result_file):
                with open(result_file) as f:
                    semgrep_results = json.load(f)

                for result in semgrep_results.get("results", []):
                    findings.append(
                        {
                            "file": result.get("path"),
                            "line": result.get("start", {}).get("line"),
                            "rule_id": result.get("check_id"),
                            "message": result.get("message"),
                            "severity": result.get("extra", {})
                            .get("severity", "MEDIUM")
                            .upper(),
                            "category": result.get("extra", {})
                            .get("metadata", {})
                            .get("category"),
                            "confidence": result.get("extra", {})
                            .get("metadata", {})
                            .get("confidence", "MEDIUM"),
                        }
                    )

            return {
                "status": "SUCCESS",
                "tool": "semgrep",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "semgrep",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_dependency_check(self) -> dict[str, Any]:
        """Run OWASP Dependency Check."""
        try:
            cmd = [
                "dependency-check",
                "--project",
                "ACGS-1",
                "--scan",
                ".",
                "--format",
                "JSON",
                "--out",
                f"logs/{self.scan_id}_dependency_check.json",
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=self.project_root,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # Parse results
            result_file = f"logs/{self.scan_id}_dependency_check.json"
            findings = []

            if os.path.exists(result_file):
                with open(result_file) as f:
                    dep_results = json.load(f)

                for dependency in dep_results.get("dependencies", []):
                    for vuln in dependency.get("vulnerabilities", []):
                        findings.append(
                            {
                                "file": dependency.get("fileName"),
                                "package": dependency.get("packages", [{}])[0].get(
                                    "id", "Unknown"
                                ),
                                "vulnerability_id": vuln.get("name"),
                                "description": vuln.get("description"),
                                "severity": vuln.get("severity", "MEDIUM").upper(),
                                "cvss_score": vuln.get("cvssv3", {}).get("baseScore"),
                                "cwe": vuln.get("cwe"),
                            }
                        )

            return {
                "status": "SUCCESS",
                "tool": "dependency-check",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "dependency-check",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_secrets_detection(self) -> dict[str, Any]:
        """Run secrets detection scan."""
        try:
            # Use truffleHog or gitleaks for secrets detection
            cmd = ["trufflehog", "filesystem", ".", "--json", "--no-update"]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=self.project_root,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            findings = []
            if stdout:
                for line in stdout.decode().strip().split("\n"):
                    if line.strip():
                        try:
                            secret = json.loads(line)
                            findings.append(
                                {
                                    "file": secret.get("SourceMetadata", {})
                                    .get("Data", {})
                                    .get("Filesystem", {})
                                    .get("file"),
                                    "detector": secret.get("DetectorName"),
                                    "verified": secret.get("Verified"),
                                    "severity": (
                                        "HIGH" if secret.get("Verified") else "MEDIUM"
                                    ),
                                    "raw": (
                                        secret.get("Raw")[:50] + "..."
                                        if secret.get("Raw")
                                        else None
                                    ),
                                }
                            )
                        except json.JSONDecodeError:
                            continue

            return {
                "status": "SUCCESS",
                "tool": "trufflehog",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "trufflehog",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_infrastructure_scan(self) -> dict[str, Any]:
        """Run infrastructure security scan."""
        try:
            findings = []

            # Check SSL/TLS configuration
            ssl_cert_path = self.project_root / "ssl" / "certs" / "acgs.pem"
            ssl_key_path = self.project_root / "ssl" / "private" / "acgs.key"

            if not ssl_cert_path.exists():
                findings.append(
                    {
                        "type": "ssl_configuration",
                        "severity": "HIGH",
                        "issue": "SSL certificate not found",
                        "file": str(ssl_cert_path),
                        "recommendation": "Generate or install SSL certificate",
                    }
                )

            if not ssl_key_path.exists():
                findings.append(
                    {
                        "type": "ssl_configuration",
                        "severity": "HIGH",
                        "issue": "SSL private key not found",
                        "file": str(ssl_key_path),
                        "recommendation": "Generate or install SSL private key",
                    }
                )

            # Check for exposed configuration files
            sensitive_files = [
                ".env",
                "config.json",
                "secrets.json",
                "private.key",
                "id_rsa",
                "id_dsa",
                "id_ecdsa",
                "id_ed25519",
            ]

            for sensitive_file in sensitive_files:
                for found_file in self.project_root.rglob(sensitive_file):
                    if "node_modules" not in str(found_file) and "target" not in str(
                        found_file
                    ):
                        findings.append(
                            {
                                "type": "sensitive_file_exposure",
                                "severity": "MEDIUM",
                                "issue": f"Potentially sensitive file found: {sensitive_file}",
                                "file": str(found_file.relative_to(self.project_root)),
                                "recommendation": "Review file permissions and consider moving to secure location",
                            }
                        )

            # Check Docker security
            docker_files = list(self.project_root.rglob("Dockerfile*"))
            for docker_file in docker_files:
                with open(docker_file) as f:
                    content = f.read()

                    # Check for running as root
                    if "USER root" in content or "USER 0" in content:
                        findings.append(
                            {
                                "type": "docker_security",
                                "severity": "HIGH",
                                "issue": "Docker container running as root user",
                                "file": str(docker_file.relative_to(self.project_root)),
                                "recommendation": "Use non-root user in Docker container",
                            }
                        )

                    # Check for hardcoded secrets
                    if any(
                        keyword in content.upper()
                        for keyword in ["PASSWORD=", "SECRET=", "TOKEN=", "KEY="]
                    ):
                        findings.append(
                            {
                                "type": "docker_security",
                                "severity": "HIGH",
                                "issue": "Potential hardcoded secrets in Dockerfile",
                                "file": str(docker_file.relative_to(self.project_root)),
                                "recommendation": "Use environment variables or secrets management",
                            }
                        )

            return {
                "status": "SUCCESS",
                "tool": "infrastructure-scan",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "infrastructure-scan",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    async def _run_service_security_check(self) -> dict[str, Any]:
        """Run security check on running services."""
        try:
            import aiohttp

            services = [
                ("auth", 8000),
                ("ac", 8001),
                ("integrity", 8002),
                ("fv", 8003),
                ("gs", 8004),
                ("pgc", 8005),
                ("ec", 8006),
            ]

            findings = []

            async with aiohttp.ClientSession() as session:
                for service_name, port in services:
                    try:
                        # Check health endpoint
                        async with session.get(
                            f"http://localhost:{port}/health", timeout=5
                        ) as response:
                            headers = dict(response.headers)

                            # Check for missing security headers
                            required_headers = [
                                "X-Content-Type-Options",
                                "X-Frame-Options",
                                "X-XSS-Protection",
                                "Strict-Transport-Security",
                                "Content-Security-Policy",
                            ]

                            for header in required_headers:
                                if header not in headers:
                                    findings.append(
                                        {
                                            "service": service_name,
                                            "port": port,
                                            "type": "missing_security_header",
                                            "severity": "MEDIUM",
                                            "issue": f"Missing security header: {header}",
                                            "recommendation": "Implement security middleware",
                                        }
                                    )

                            # Check for HTTP instead of HTTPS
                            if response.url.scheme == "http":
                                findings.append(
                                    {
                                        "service": service_name,
                                        "port": port,
                                        "type": "insecure_protocol",
                                        "severity": "HIGH",
                                        "issue": "Service accessible over HTTP instead of HTTPS",
                                        "recommendation": "Enforce HTTPS for all services",
                                    }
                                )

                    except Exception as e:
                        findings.append(
                            {
                                "service": service_name,
                                "port": port,
                                "type": "service_unavailable",
                                "severity": "LOW",
                                "issue": f"Service not accessible: {e}",
                                "recommendation": "Verify service is running and accessible",
                            }
                        )

            return {
                "status": "SUCCESS",
                "tool": "service-security-check",
                "findings_count": len(findings),
                "findings": findings,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

        except Exception as e:
            return {
                "status": "FAILED",
                "tool": "service-security-check",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }

    def _update_summary(self, scan_result: dict[str, Any]) -> None:
        """Update summary with scan results."""
        if scan_result.get("status") == "SUCCESS":
            findings = scan_result.get("findings", [])
            for finding in findings:
                severity = finding.get("severity", "UNKNOWN").upper()
                if severity == "CRITICAL":
                    self.results["summary"]["critical_findings"] += 1
                elif severity == "HIGH":
                    self.results["summary"]["high_findings"] += 1
                elif severity == "MEDIUM":
                    self.results["summary"]["medium_findings"] += 1
                elif severity == "LOW":
                    self.results["summary"]["low_findings"] += 1

        self.results["summary"]["total_findings"] = (
            self.results["summary"]["critical_findings"]
            + self.results["summary"]["high_findings"]
            + self.results["summary"]["medium_findings"]
            + self.results["summary"]["low_findings"]
        )

    def _assess_compliance(self) -> None:
        """Assess overall compliance status."""
        critical = self.results["summary"]["critical_findings"]
        high = self.results["summary"]["high_findings"]

        if critical > 0:
            self.results["compliance_status"] = "NON_COMPLIANT_CRITICAL"
        elif high > 10:
            self.results["compliance_status"] = "NON_COMPLIANT_HIGH"
        elif high > 0:
            self.results["compliance_status"] = "NEEDS_IMPROVEMENT"
        else:
            self.results["compliance_status"] = "COMPLIANT"

    def _generate_recommendations(self) -> None:
        """Generate security recommendations based on findings."""
        recommendations = []

        critical = self.results["summary"]["critical_findings"]
        high = self.results["summary"]["high_findings"]

        if critical > 0:
            recommendations.append(
                {
                    "priority": "CRITICAL",
                    "action": "Immediately address all critical security vulnerabilities",
                    "timeline": "Within 24 hours",
                    "impact": "System compromise risk",
                }
            )

        if high > 0:
            recommendations.append(
                {
                    "priority": "HIGH",
                    "action": f"Address {high} high-severity security findings",
                    "timeline": "Within 1 week",
                    "impact": "Significant security risk",
                }
            )

        # Check for missing security middleware
        service_scans = self.results["scans"].get("service_security_check", {})
        if service_scans.get("status") == "SUCCESS":
            missing_headers = sum(
                1
                for finding in service_scans.get("findings", [])
                if finding.get("type") == "missing_security_header"
            )
            if missing_headers > 0:
                recommendations.append(
                    {
                        "priority": "HIGH",
                        "action": "Implement security middleware across all services",
                        "timeline": "Within 3 days",
                        "impact": "XSS, CSRF, and other web vulnerabilities",
                    }
                )

        # Check for dependency vulnerabilities
        dep_scans = [
            "python_safety",
            "python_pip_audit",
            "javascript_npm_audit",
            "rust_cargo_audit",
        ]
        total_dep_vulns = 0
        for scan_name in dep_scans:
            scan_result = self.results["scans"].get(scan_name, {})
            if scan_result.get("status") == "SUCCESS":
                total_dep_vulns += scan_result.get("findings_count", 0)

        if total_dep_vulns > 0:
            recommendations.append(
                {
                    "priority": "MEDIUM",
                    "action": f"Update {total_dep_vulns} vulnerable dependencies",
                    "timeline": "Within 2 weeks",
                    "impact": "Known vulnerability exploitation",
                }
            )

        self.results["recommendations"] = recommendations

    async def _save_results(self) -> None:
        """Save scan results to files."""
        # Save detailed results
        results_file = f"reports/security/{self.scan_id}_detailed_results.json"
        with open(results_file, "w") as f:
            json.dump(self.results, f, indent=2)

        # Save summary report
        summary_file = f"reports/security/{self.scan_id}_summary.json"
        summary = {
            "scan_id": self.scan_id,
            "timestamp": self.results["timestamp"],
            "summary": self.results["summary"],
            "compliance_status": self.results["compliance_status"],
            "recommendations": self.results["recommendations"],
            "scan_status": {
                scan_name: scan_result.get("status", "UNKNOWN")
                for scan_name, scan_result in self.results["scans"].items()
            },
        }

        with open(summary_file, "w") as f:
            json.dump(summary, f, indent=2)

        logger.info(f"üìä Results saved to {results_file}")
        logger.info(f"üìã Summary saved to {summary_file}")


async def main():
    """Main execution function."""
    scanner = SecurityVulnerabilityScanner()

    try:
        results = await scanner.run_comprehensive_scan()

        # Print summary
        print("\n" + "=" * 80)
        print("üîç ACGS-1 SECURITY VULNERABILITY SCAN RESULTS")
        print("=" * 80)
        print(f"Scan ID: {results['scan_id']}")
        print(f"Timestamp: {results['timestamp']}")
        print(f"Compliance Status: {results['compliance_status']}")
        print("\nFindings Summary:")
        print(f"  Critical: {results['summary']['critical_findings']}")
        print(f"  High:     {results['summary']['high_findings']}")
        print(f"  Medium:   {results['summary']['medium_findings']}")
        print(f"  Low:      {results['summary']['low_findings']}")
        print(f"  Total:    {results['summary']['total_findings']}")

        print("\nRecommendations:")
        for i, rec in enumerate(results["recommendations"], 1):
            print(f"  {i}. [{rec['priority']}] {rec['action']}")
            print(f"     Timeline: {rec['timeline']}")
            print(f"     Impact: {rec['impact']}")

        print("\nScan Status:")
        for scan_name, scan_result in results["scans"].items():
            status = scan_result.get("status", "UNKNOWN")
            findings_count = scan_result.get("findings_count", 0)
            print(f"  {scan_name}: {status} ({findings_count} findings)")

        print("=" * 80)

        return 0 if results["summary"]["critical_findings"] == 0 else 1

    except Exception as e:
        logger.error(f"‚ùå Security scan failed: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
