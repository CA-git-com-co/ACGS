#!/usr/bin/env python3
"""
ACGS-2 Continuous Security Monitoring
Constitutional Hash: cdd01ef066bc6cf2

Real-time vulnerability monitoring and alerting for ACGS-2 production systems.
Addresses the 70 identified vulnerabilities with continuous scanning and reporting.
"""

import subprocess
import json
import logging
import asyncio
import aiohttp
import smtplib
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Any, Optional
from pathlib import Path
import sys
import os

# Add project root to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

class ACGSSecurityMonitor:
    """Continuous security monitoring for ACGS-2"""
    
    def __init__(self):
        self.constitutional_hash = "cdd01ef066bc6cf2"
        self.logger = self._setup_logging()
        self.critical_packages = [
            'Pillow', 'cryptography', 'nltk', 'transformers', 
            'requests', 'urllib3', 'black', 'tqdm'
        ]
        self.alert_thresholds = {
            'critical': 0,     # Zero tolerance for critical vulnerabilities
            'high': 3,         # Alert if more than 3 high severity
            'medium': 10,      # Alert if more than 10 medium severity
            'low': 20          # Alert if more than 20 low severity
        }
        
    def scan_dependencies(self) -> Dict[str, Any]:
        """Scan for dependency vulnerabilities using pip-audit"""
        try:
            self.logger.info("Starting dependency vulnerability scan")
            
            # Run pip-audit with JSON output
            result = subprocess.run([
                'pip-audit', '--format', 'json', '--desc', '--progress-spinner=off'
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                try:
                    vulnerabilities = json.loads(result.stdout) if result.stdout else []
                except json.JSONDecodeError:
                    vulnerabilities = []
                    
                scan_result = {
                    'status': 'success',
                    'vulnerabilities': vulnerabilities,
                    'scan_time': datetime.now().isoformat(),
                    'constitutional_hash': self.constitutional_hash,
                    'tool': 'pip-audit',
                    'command': 'pip-audit --format json --desc'
                }
                
                self.logger.info(f"Dependency scan completed. Found {len(vulnerabilities)} vulnerabilities")
                return scan_result
                
            else:
                error_msg = result.stderr or "Unknown error during pip-audit scan"
                self.logger.error(f"pip-audit failed: {error_msg}")
                return {
                    'status': 'error',
                    'error': error_msg,
                    'constitutional_hash': self.constitutional_hash,
                    'tool': 'pip-audit'
                }
                
        except subprocess.TimeoutExpired:
            self.logger.error("pip-audit scan timed out after 5 minutes")
            return {
                'status': 'timeout',
                'error': 'Scan timed out after 5 minutes',
                'constitutional_hash': self.constitutional_hash
            }
        except Exception as e:
            self.logger.error(f"Security scan failed: {e}")
            return {
                'status': 'error',
                'error': str(e),
                'constitutional_hash': self.constitutional_hash
            }
    
    def check_critical_packages(self) -> List[Dict[str, Any]]:
        """Check critical packages for known vulnerabilities using safety"""
        results = []
        
        for package in self.critical_packages:
            try:
                self.logger.debug(f"Checking package: {package}")
                
                # Use safety to check individual package
                result = subprocess.run([
                    'safety', 'check', '--json', '--continue-on-error'
                ], capture_output=True, text=True, timeout=60)
                
                package_result = {
                    'package': package,
                    'status': 'checked',
                    'constitutional_hash': self.constitutional_hash,
                    'scan_time': datetime.now().isoformat()
                }
                
                if result.stdout:
                    try:
                        safety_data = json.loads(result.stdout)
                        package_result['safety_results'] = safety_data
                    except json.JSONDecodeError:
                        package_result['safety_results'] = {'raw_output': result.stdout}
                
                if result.stderr:
                    package_result['warnings'] = result.stderr
                    
                results.append(package_result)
                
            except subprocess.TimeoutExpired:
                results.append({
                    'package': package,
                    'status': 'timeout',
                    'error': 'Safety check timed out',
                    'constitutional_hash': self.constitutional_hash
                })
            except Exception as e:
                results.append({
                    'package': package,
                    'status': 'error',
                    'error': str(e),
                    'constitutional_hash': self.constitutional_hash
                })
        
        return results
    
    def analyze_github_alerts(self) -> Dict[str, Any]:
        """Analyze GitHub Dependabot alerts if available"""
        try:
            # Check if gh CLI is available and configured
            result = subprocess.run([
                'gh', 'api', 'repos/CA-git-com-co/ACGS/dependabot/alerts',
                '--jq', '.[] | select(.state == "open") | {number, severity: .security_advisory.severity, package: .dependency.package.name, summary: .security_advisory.summary}'
            ], capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 and result.stdout:
                alerts = []
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        try:
                            alert = json.loads(line)
                            alerts.append(alert)
                        except json.JSONDecodeError:
                            continue
                
                return {
                    'status': 'success',
                    'alerts': alerts,
                    'count': len(alerts),
                    'constitutional_hash': self.constitutional_hash
                }
            else:
                return {
                    'status': 'unavailable',
                    'message': 'GitHub CLI not configured or no access to repository',
                    'constitutional_hash': self.constitutional_hash
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e),
                'constitutional_hash': self.constitutional_hash
            }
    
    def calculate_security_score(self, vulnerabilities: List[Dict], github_alerts: Dict) -> Dict[str, Any]:
        """Calculate security score based on vulnerabilities found"""
        base_score = 100
        deductions = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        
        # Process pip-audit vulnerabilities
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'unknown').lower()
            if severity == 'critical':
                base_score -= 25
                deductions['critical'] += 1
            elif severity == 'high':
                base_score -= 15
                deductions['high'] += 1
            elif severity == 'medium':
                base_score -= 5
                deductions['medium'] += 1
            elif severity == 'low':
                base_score -= 2
                deductions['low'] += 1
        
        # Process GitHub alerts
        if github_alerts.get('status') == 'success':
            for alert in github_alerts.get('alerts', []):
                severity = alert.get('severity', 'unknown').lower()
                if severity == 'critical':
                    base_score -= 20
                    deductions['critical'] += 1
                elif severity == 'high':
                    base_score -= 10
                    deductions['high'] += 1
                elif severity == 'medium':
                    base_score -= 3
                    deductions['medium'] += 1
                elif severity == 'low':
                    base_score -= 1
                    deductions['low'] += 1
        
        final_score = max(0, base_score)
        
        return {
            'score': final_score,
            'grade': self._get_security_grade(final_score),
            'deductions': deductions,
            'total_vulnerabilities': sum(deductions.values()),
            'constitutional_hash': self.constitutional_hash
        }
    
    def _get_security_grade(self, score: int) -> str:
        """Convert security score to letter grade"""
        if score >= 95:
            return 'A+'
        elif score >= 90:
            return 'A'
        elif score >= 85:
            return 'B+'
        elif score >= 80:
            return 'B'
        elif score >= 75:
            return 'C+'
        elif score >= 70:
            return 'C'
        elif score >= 60:
            return 'D'
        else:
            return 'F'
    
    def generate_recommendations(self, vulnerabilities: List[Dict], security_score: Dict) -> List[str]:
        """Generate actionable security recommendations"""
        recommendations = []
        
        deductions = security_score.get('deductions', {})
        
        if deductions.get('critical', 0) > 0:
            recommendations.append(
                f"üö® URGENT: {deductions['critical']} critical vulnerabilities detected. "
                "Stop all deployments and update dependencies immediately."
            )
        
        if deductions.get('high', 0) > self.alert_thresholds['high']:
            recommendations.append(
                f"‚ö†Ô∏è HIGH PRIORITY: {deductions['high']} high-severity vulnerabilities. "
                "Schedule immediate security updates within 24 hours."
            )
        
        if deductions.get('medium', 0) > self.alert_thresholds['medium']:
            recommendations.append(
                f"üìã MEDIUM PRIORITY: {deductions['medium']} medium-severity vulnerabilities. "
                "Plan security updates within 7 days."
            )
        
        # General recommendations
        if security_score.get('score', 0) < 80:
            recommendations.extend([
                "üìä Enable automated dependency updates with Dependabot",
                "üîç Implement security scanning in CI/CD pipeline",
                "üìÖ Schedule weekly security vulnerability reviews",
                "üõ°Ô∏è Consider implementing additional security layers",
                "üìö Review and update security documentation"
            ])
        
        # Always include constitutional compliance reminder
        recommendations.append(
            f"‚úÖ Maintain constitutional compliance (hash: {self.constitutional_hash}) "
            "during all security updates"
        )
        
        return recommendations
    
    def check_alert_thresholds(self, security_score: Dict) -> List[str]:
        """Check if vulnerabilities exceed alert thresholds"""
        alerts = []
        deductions = security_score.get('deductions', {})
        
        for severity, count in deductions.items():
            threshold = self.alert_thresholds.get(severity, float('inf'))
            if count > threshold:
                alerts.append(
                    f"ALERT: {count} {severity.upper()} vulnerabilities exceed threshold of {threshold}"
                )
        
        return alerts
    
    def generate_security_report(self) -> Dict[str, Any]:
        """Generate comprehensive security report"""
        self.logger.info("Generating comprehensive security report")
        
        # Run all security checks
        dependency_scan = self.scan_dependencies()
        critical_check = self.check_critical_packages()
        github_alerts = self.analyze_github_alerts()
        
        # Calculate security metrics
        vulnerabilities = dependency_scan.get('vulnerabilities', [])
        security_score = self.calculate_security_score(vulnerabilities, github_alerts)
        recommendations = self.generate_recommendations(vulnerabilities, security_score)
        alerts = self.check_alert_thresholds(security_score)
        
        # Generate comprehensive report
        report = {
            'report_metadata': {
                'generated_at': datetime.now().isoformat(),
                'constitutional_hash': self.constitutional_hash,
                'version': '1.0.0',
                'tool_version': 'ACGS-2 Security Monitor'
            },
            'security_summary': {
                'score': security_score.get('score', 0),
                'grade': security_score.get('grade', 'F'),
                'total_vulnerabilities': security_score.get('total_vulnerabilities', 0),
                'critical_count': security_score.get('deductions', {}).get('critical', 0),
                'high_count': security_score.get('deductions', {}).get('high', 0),
                'medium_count': security_score.get('deductions', {}).get('medium', 0),
                'low_count': security_score.get('deductions', {}).get('low', 0)
            },
            'scan_results': {
                'dependency_scan': dependency_scan,
                'critical_packages': critical_check,
                'github_alerts': github_alerts
            },
            'security_analysis': {
                'score_breakdown': security_score,
                'recommendations': recommendations,
                'alerts': alerts,
                'risk_level': self._assess_risk_level(security_score)
            },
            'next_steps': {
                'immediate_actions': self._get_immediate_actions(security_score),
                'weekly_tasks': [
                    "Run comprehensive security scan",
                    "Review and update security dependencies",
                    "Check for new security advisories",
                    "Validate constitutional compliance"
                ],
                'next_review_date': (datetime.now() + timedelta(days=7)).isoformat()
            }
        }
        
        # Save report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f'security_report_{timestamp}.json'
        
        try:
            with open(report_file, 'w') as f:
                json.dump(report, f, indent=2)
            self.logger.info(f"Security report saved to: {report_file}")
            report['report_file'] = report_file
        except Exception as e:
            self.logger.error(f"Failed to save report: {e}")
        
        return report
    
    def _assess_risk_level(self, security_score: Dict) -> str:
        """Assess overall security risk level"""
        score = security_score.get('score', 0)
        deductions = security_score.get('deductions', {})
        
        if deductions.get('critical', 0) > 0:
            return 'CRITICAL'
        elif deductions.get('high', 0) > 5:
            return 'HIGH'
        elif score < 70:
            return 'MEDIUM'
        elif score < 85:
            return 'LOW'
        else:
            return 'MINIMAL'
    
    def _get_immediate_actions(self, security_score: Dict) -> List[str]:
        """Get immediate actions based on security score"""
        actions = []
        deductions = security_score.get('deductions', {})
        
        if deductions.get('critical', 0) > 0:
            actions.extend([
                "STOP all production deployments immediately",
                "Update critical packages: Pillow, cryptography, nltk",
                "Run emergency security patch deployment",
                "Notify security team and stakeholders"
            ])
        
        if deductions.get('high', 0) > 0:
            actions.extend([
                "Schedule high-priority security updates",
                "Review affected services and components",
                "Plan coordinated security update deployment"
            ])
        
        if not actions:
            actions.append("Continue regular monitoring and maintenance")
        
        return actions
    
    def _setup_logging(self) -> logging.Logger:
        """Setup security monitoring logging"""
        logger = logging.getLogger('acgs_security_monitor')
        logger.setLevel(logging.INFO)
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)
        
        # File handler
        try:
            file_handler = logging.FileHandler('acgs_security_monitor.log')
            file_formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            file_handler.setFormatter(file_formatter)
            logger.addHandler(file_handler)
        except Exception as e:
            logger.warning(f"Could not setup file logging: {e}")
        
        return logger

async def run_continuous_monitoring(interval_hours: int = 6):
    """Run continuous security monitoring"""
    monitor = ACGSSecurityMonitor()
    
    while True:
        try:
            print(f"\n{'='*80}")
            print(f"üîç ACGS-2 Security Scan - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"{'='*80}")
            
            report = monitor.generate_security_report()
            
            # Print summary
            summary = report.get('security_summary', {})
            print(f"\nüìä Security Score: {summary.get('score', 0)}/100 (Grade: {summary.get('grade', 'F')})")
            print(f"üö® Critical: {summary.get('critical_count', 0)}")
            print(f"‚ö†Ô∏è  High: {summary.get('high_count', 0)}")
            print(f"üìã Medium: {summary.get('medium_count', 0)}")
            print(f"üìå Low: {summary.get('low_count', 0)}")
            
            # Print alerts
            alerts = report.get('security_analysis', {}).get('alerts', [])
            if alerts:
                print(f"\nüö® SECURITY ALERTS:")
                for alert in alerts:
                    print(f"   {alert}")
            
            # Print recommendations
            recommendations = report.get('security_analysis', {}).get('recommendations', [])
            if recommendations:
                print(f"\nüí° RECOMMENDATIONS:")
                for rec in recommendations[:3]:  # Show top 3
                    print(f"   {rec}")
            
            print(f"\n‚úÖ Constitutional Hash: {monitor.constitutional_hash}")
            print(f"üìÑ Report saved: {report.get('report_file', 'N/A')}")
            
            # Wait for next scan
            wait_seconds = interval_hours * 3600
            print(f"\n‚è∞ Next scan in {interval_hours} hours...")
            await asyncio.sleep(wait_seconds)
            
        except KeyboardInterrupt:
            print("\nüõë Monitoring stopped by user")
            break
        except Exception as e:
            monitor.logger.error(f"Error in continuous monitoring: {e}")
            print(f"‚ùå Error: {e}")
            # Wait 5 minutes before retrying
            await asyncio.sleep(300)

def main():
    """Main execution function"""
    import argparse
    
    parser = argparse.ArgumentParser(description='ACGS-2 Security Vulnerability Monitor')
    parser.add_argument('--mode', choices=['single', 'continuous'], default='single',
                       help='Run mode: single scan or continuous monitoring')
    parser.add_argument('--interval', type=int, default=6,
                       help='Monitoring interval in hours (for continuous mode)')
    
    args = parser.parse_args()
    
    if args.mode == 'single':
        # Single scan mode
        monitor = ACGSSecurityMonitor()
        print(f"üîç Running ACGS-2 Security Scan...")
        print(f"Constitutional Hash: {monitor.constitutional_hash}")
        
        report = monitor.generate_security_report()
        
        # Print results
        summary = report.get('security_summary', {})
        print(f"\nüìä Security Report Generated")
        print(f"   Score: {summary.get('score', 0)}/100 (Grade: {summary.get('grade', 'F')})")
        print(f"   Total Vulnerabilities: {summary.get('total_vulnerabilities', 0)}")
        print(f"   Risk Level: {report.get('security_analysis', {}).get('risk_level', 'UNKNOWN')}")
        
        # Exit with appropriate code
        score = summary.get('score', 0)
        if score >= 90:
            print(f"\n‚úÖ EXCELLENT: Security score is excellent")
            sys.exit(0)
        elif score >= 80:
            print(f"\n‚úÖ GOOD: Security score is acceptable")
            sys.exit(0)
        elif score >= 70:
            print(f"\n‚ö†Ô∏è  WARNING: Security score needs improvement")
            sys.exit(1)
        else:
            print(f"\nüö® CRITICAL: Security score is unacceptable for production")
            sys.exit(2)
    
    else:
        # Continuous monitoring mode
        print(f"üîÑ Starting continuous security monitoring...")
        print(f"   Interval: {args.interval} hours")
        print(f"   Press Ctrl+C to stop")
        
        try:
            asyncio.run(run_continuous_monitoring(args.interval))
        except KeyboardInterrupt:
            print(f"\n‚úÖ Monitoring stopped gracefully")
            sys.exit(0)

if __name__ == "__main__":
    main()