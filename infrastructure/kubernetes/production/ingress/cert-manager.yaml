# Constitutional Hash: cdd01ef066bc6cf2
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@acgs-pgp.com
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
      - http01:
          ingress:
            class: nginx
      - dns01:
          cloudflare:
            email: admin@acgs-pgp.com
            apiTokenSecretRef:
              name: cloudflare-api-token
              key: api-token

---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-staging
spec:
  acme:
    server: https://acme-staging-v02.api.letsencrypt.org/directory
    email: admin@acgs-pgp.com
    privateKeySecretRef:
      name: letsencrypt-staging
    solvers:
      - http01:
          ingress:
            class: nginx
      - dns01:
          cloudflare:
            email: admin@acgs-pgp.com
            apiTokenSecretRef:
              name: cloudflare-api-token
              key: api-token

---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: acgs-pgp-tls
  namespace: acgs-pgp
spec:
  secretName: acgs-pgp-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - api.acgs-pgp.com
    - app.acgs-pgp.com
    - admin.acgs-pgp.com
    - monitoring.acgs-pgp.com

---
apiVersion: v1
kind: Secret
metadata:
  name: cloudflare-api-token
  namespace: cert-manager
type: Opaque
stringData:
  api-token: 'CLOUDFLARE_API_TOKEN_PLACEHOLDER'

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: cert-manager-network-policy
  namespace: cert-manager
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: cert-manager
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: TCP
          port: 9402
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53

---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: cert-manager-metrics
  namespace: cert-manager
  labels:
    app.kubernetes.io/name: cert-manager
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: cert-manager
  endpoints:
    - port: tcp-prometheus-servicemonitor
      interval: 30s
      path: /metrics

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cert-manager-webhook-config
  namespace: cert-manager
data:
  config.yaml: |
    apiVersion: webhook.cert-manager.io/v1alpha1
    kind: WebhookConfiguration
    metadata:
      name: cert-manager-webhook
    webhooks:
    - name: webhook.cert-manager.io
      rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["cert-manager.io"]
        apiVersions: ["v1"]
        resources: ["certificates", "issuers", "clusterissuers"]
      clientConfig:
        service:
          name: cert-manager-webhook
          namespace: cert-manager
          path: /mutate
      admissionReviewVersions: ["v1", "v1beta1"]
      sideEffects: None
      failurePolicy: Fail

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cert-renewal-check
  namespace: cert-manager
spec:
  schedule: '0 2 * * *' # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: cert-check
              image: bitnami/kubectl:latest
              command:
                - /bin/sh
                - -c
                - |
                  echo "Checking certificate expiration..."
                  kubectl get certificates -A -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name,READY:.status.conditions[0].status,SECRET:.spec.secretName,ISSUER:.spec.issuerRef.name

                  # Check certificates expiring in next 30 days
                  kubectl get secrets -A -o json | jq -r '.items[] | select(.type=="kubernetes.io/tls") | select(.data."tls.crt") | .metadata.namespace + "/" + .metadata.name' | while read cert; do
                    namespace=$(echo $cert | cut -d'/' -f1)
                    name=$(echo $cert | cut -d'/' -f2)
                    expiry=$(kubectl get secret $name -n $namespace -o jsonpath='{.data.tls\.crt}' | base64 -d | openssl x509 -noout -enddate | cut -d'=' -f2)
                    echo "Certificate $namespace/$name expires: $expiry"
                  done
          restartPolicy: OnFailure
          serviceAccountName: cert-manager

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cert-manager
  namespace: cert-manager

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cert-manager
rules:
  - apiGroups: ['']
    resources: ['secrets']
    verbs: ['get', 'list', 'watch']
  - apiGroups: ['cert-manager.io']
    resources: ['certificates', 'issuers', 'clusterissuers']
    verbs: ['get', 'list', 'watch']

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cert-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager
subjects:
  - kind: ServiceAccount
    name: cert-manager
    namespace: cert-manager
