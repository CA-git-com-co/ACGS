"""
Federated Evaluation Dashboard

Plotly Dash dashboard for visualizing federated evaluation metrics,
privacy budget usage, and cross-platform performance comparison.
"""

import logging
from datetime import datetime, timedelta

import plotly.graph_objs as go

try:
    import dash
    import dash_bootstrap_components as dbc
    from dash import Input, Output, dcc, html

    DASH_AVAILABLE = True
except ImportError:
    DASH_AVAILABLE = False

logger = logging.getLogger(__name__)


def create_dash_app():
    """Create and configure the Dash dashboard application."""
    if not DASH_AVAILABLE:
        logger.warning("Dash not available. Dashboard will not be functional.")
        return None

    try:
        # Create Dash app
        app = dash.Dash(
            __name__,
            external_stylesheets=[dbc.themes.BOOTSTRAP],
            url_base_pathname="/dashboard/",
        )

        # Define layout
        app.layout = create_dashboard_layout()

        # Register callbacks
        register_callbacks(app)

        logger.info("Federated evaluation dashboard created successfully")
        return app

    except Exception as e:
        logger.error(f"Failed to create dashboard: {e}")
        return None


def create_dashboard_layout():
    """Create the dashboard layout."""
    if not DASH_AVAILABLE:
        return html.Div("Dashboard not available")

    return dbc.Container(
        [
            # Header
            dbc.Row(
                [
                    dbc.Col(
                        [
                            html.H1(
                                "ACGS-PGP Federated Evaluation Dashboard",
                                className="text-center mb-4",
                            ),
                            html.Hr(),
                        ]
                    )
                ]
            ),
            # Metrics Cards
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardBody(
                                        [
                                            html.H4(
                                                "Active Nodes", className="card-title"
                                            ),
                                            html.H2(
                                                id="active-nodes-count",
                                                children="0",
                                                className="text-primary",
                                            ),
                                            html.P(
                                                "Federated evaluation nodes",
                                                className="card-text",
                                            ),
                                        ]
                                    )
                                ]
                            )
                        ],
                        width=3,
                    ),
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardBody(
                                        [
                                            html.H4(
                                                "Privacy Budget", className="card-title"
                                            ),
                                            html.H2(
                                                id="privacy-budget-remaining",
                                                children="0%",
                                                className="text-success",
                                            ),
                                            html.P(
                                                "Epsilon remaining",
                                                className="card-text",
                                            ),
                                        ]
                                    )
                                ]
                            )
                        ],
                        width=3,
                    ),
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardBody(
                                        [
                                            html.H4(
                                                "Success Rate", className="card-title"
                                            ),
                                            html.H2(
                                                id="success-rate",
                                                children="0%",
                                                className="text-info",
                                            ),
                                            html.P(
                                                "Evaluation success rate",
                                                className="card-text",
                                            ),
                                        ]
                                    )
                                ]
                            )
                        ],
                        width=3,
                    ),
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardBody(
                                        [
                                            html.H4(
                                                "Avg Response Time",
                                                className="card-title",
                                            ),
                                            html.H2(
                                                id="avg-response-time",
                                                children="0ms",
                                                className="text-warning",
                                            ),
                                            html.P(
                                                "Cross-platform average",
                                                className="card-text",
                                            ),
                                        ]
                                    )
                                ]
                            )
                        ],
                        width=3,
                    ),
                ],
                className="mb-4",
            ),
            # Charts Row 1
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardHeader("Evaluation Performance Over Time"),
                                    dbc.CardBody(
                                        [dcc.Graph(id="performance-timeline")]
                                    ),
                                ]
                            )
                        ],
                        width=6,
                    ),
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardHeader("Cross-Platform Comparison"),
                                    dbc.CardBody([dcc.Graph(id="platform-comparison")]),
                                ]
                            )
                        ],
                        width=6,
                    ),
                ],
                className="mb-4",
            ),
            # Charts Row 2
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardHeader("Privacy Budget Usage"),
                                    dbc.CardBody(
                                        [dcc.Graph(id="privacy-budget-chart")]
                                    ),
                                ]
                            )
                        ],
                        width=6,
                    ),
                    dbc.Col(
                        [
                            dbc.Card(
                                [
                                    dbc.CardHeader("Node Status Distribution"),
                                    dbc.CardBody([dcc.Graph(id="node-status-chart")]),
                                ]
                            )
                        ],
                        width=6,
                    ),
                ],
                className="mb-4",
            ),
            # Refresh interval
            dcc.Interval(
                id="interval-component",
                interval=30 * 1000,  # Update every 30 seconds
                n_intervals=0,
            ),
        ],
        fluid=True,
    )


def register_callbacks(app):
    """Register dashboard callbacks."""
    if not DASH_AVAILABLE:
        return

    @app.callback(
        [
            Output("active-nodes-count", "children"),
            Output("privacy-budget-remaining", "children"),
            Output("success-rate", "children"),
            Output("avg-response-time", "children"),
            Output("performance-timeline", "figure"),
            Output("platform-comparison", "figure"),
            Output("privacy-budget-chart", "figure"),
            Output("node-status-chart", "figure"),
        ],
        [Input("interval-component", "n_intervals")],
    )
    def update_dashboard(n):
        """Update all dashboard components."""
        try:
            # Mock data - would fetch from actual federated evaluator
            metrics = get_mock_metrics()

            # Update metric cards
            active_nodes = str(metrics["active_nodes"])
            privacy_budget = f"{metrics['privacy_budget_remaining']:.1%}"
            success_rate = f"{metrics['success_rate']:.1%}"
            avg_response_time = f"{metrics['avg_response_time']:.0f}ms"

            # Create charts
            performance_fig = create_performance_timeline(metrics)
            platform_fig = create_platform_comparison(metrics)
            privacy_fig = create_privacy_budget_chart(metrics)
            node_status_fig = create_node_status_chart(metrics)

            return (
                active_nodes,
                privacy_budget,
                success_rate,
                avg_response_time,
                performance_fig,
                platform_fig,
                privacy_fig,
                node_status_fig,
            )

        except Exception as e:
            logger.error(f"Failed to update dashboard: {e}")
            # Return default values
            return "0", "0%", "0%", "0ms", {}, {}, {}, {}


def get_mock_metrics():
    """Get mock metrics for dashboard demonstration."""
    import random

    # Generate mock time series data
    now = datetime.now()
    times = [now - timedelta(minutes=i * 5) for i in range(12, 0, -1)]

    return {
        "active_nodes": 3,
        "privacy_budget_remaining": 0.65,
        "success_rate": 0.94,
        "avg_response_time": 145.2,
        "timeline_data": {
            "timestamps": times,
            "success_rates": [random.uniform(0.85, 0.98) for _ in times],
            "response_times": [random.uniform(100, 200) for _ in times],
            "privacy_scores": [random.uniform(0.9, 0.99) for _ in times],
        },
        "platform_data": {
            "platforms": ["OpenAI", "Anthropic", "Cohere", "Groq"],
            "success_rates": [0.96, 0.94, 0.92, 0.89],
            "response_times": [120, 135, 160, 180],
            "consistency_scores": [0.94, 0.91, 0.88, 0.85],
        },
        "privacy_usage": {
            "epsilon_used": 0.35,
            "epsilon_total": 1.0,
            "queries_over_time": [random.randint(5, 15) for _ in times],
        },
        "node_status": {"active": 3, "inactive": 1, "error": 0},
    }


def create_performance_timeline(metrics):
    """Create performance timeline chart."""
    if not DASH_AVAILABLE:
        return {}

    timeline = metrics["timeline_data"]

    fig = go.Figure()

    # Success rate line
    fig.add_trace(
        go.Scatter(
            x=timeline["timestamps"],
            y=timeline["success_rates"],
            mode="lines+markers",
            name="Success Rate",
            line=dict(color="#28a745"),
            yaxis="y",
        )
    )

    # Response time line (secondary y-axis)
    fig.add_trace(
        go.Scatter(
            x=timeline["timestamps"],
            y=timeline["response_times"],
            mode="lines+markers",
            name="Response Time (ms)",
            line=dict(color="#ffc107"),
            yaxis="y2",
        )
    )

    fig.update_layout(
        title="Evaluation Performance Timeline",
        xaxis_title="Time",
        yaxis=dict(title="Success Rate", side="left", range=[0, 1]),
        yaxis2=dict(title="Response Time (ms)", side="right", overlaying="y"),
        legend=dict(x=0, y=1),
        height=400,
    )

    return fig


def create_platform_comparison(metrics):
    """Create cross-platform comparison chart."""
    if not DASH_AVAILABLE:
        return {}

    platform_data = metrics["platform_data"]

    fig = go.Figure()

    # Success rates bar chart
    fig.add_trace(
        go.Bar(
            x=platform_data["platforms"],
            y=platform_data["success_rates"],
            name="Success Rate",
            marker_color="#007bff",
        )
    )

    fig.update_layout(
        title="Cross-Platform Success Rates",
        xaxis_title="Platform",
        yaxis_title="Success Rate",
        yaxis=dict(range=[0, 1]),
        height=400,
    )

    return fig


def create_privacy_budget_chart(metrics):
    """Create privacy budget usage chart."""
    if not DASH_AVAILABLE:
        return {}

    privacy_data = metrics["privacy_usage"]

    # Pie chart for budget usage
    fig = go.Figure(
        data=[
            go.Pie(
                labels=["Used", "Remaining"],
                values=[
                    privacy_data["epsilon_used"],
                    privacy_data["epsilon_total"] - privacy_data["epsilon_used"],
                ],
                hole=0.4,
                marker_colors=["#dc3545", "#28a745"],
            )
        ]
    )

    fig.update_layout(
        title="Privacy Budget (Epsilon) Usage",
        height=400,
        annotations=[
            dict(
                text=f"ε = {privacy_data['epsilon_total']}",
                x=0.5,
                y=0.5,
                font_size=20,
                showarrow=False,
            )
        ],
    )

    return fig


def create_node_status_chart(metrics):
    """Create node status distribution chart."""
    if not DASH_AVAILABLE:
        return {}

    node_status = metrics["node_status"]

    fig = go.Figure(
        data=[
            go.Bar(
                x=list(node_status.keys()),
                y=list(node_status.values()),
                marker_color=["#28a745", "#6c757d", "#dc3545"],
            )
        ]
    )

    fig.update_layout(
        title="Federated Node Status",
        xaxis_title="Status",
        yaxis_title="Count",
        height=400,
    )

    return fig
