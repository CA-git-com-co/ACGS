"""
OPA Bundle Manager for RAG-Generated Rules

This module provides comprehensive OPA bundle compilation, validation, and deployment
functionality for rules generated by the RAG-based rule generator.

Constitutional Hash: cdd01ef066bc6cf2

Key Features:
- Rego rule compilation and validation
- Bundle generation with metadata
- Deployment to OPA server with rollback capability
- Performance monitoring and metrics
- Constitutional compliance validation
"""

import asyncio
import json
import logging
import os
import tempfile
import time
import zipfile
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

import aiofiles
import httpx

from .opa_client import OPAClient, PolicyBundle, get_opa_client
from .rag_rule_generator import RegoRuleResult

# Constitutional compliance hash for ACGS-2
CONSTITUTIONAL_HASH = "cdd01ef066bc6cf2"

logger = logging.getLogger(__name__)


@dataclass
class BundleMetadata:
    """Metadata for OPA policy bundle."""
    
    bundle_id: str
    name: str
    version: str
    created_at: datetime
    rules_count: int
    source_principles: List[str]
    constitutional_hash: str = CONSTITUTIONAL_HASH
    deployment_status: str = "pending"
    validation_results: Dict[str, Any] = field(default_factory=dict)


@dataclass
class CompilationResult:
    """Result of Rego rule compilation."""
    
    rule_id: str
    compiled_successfully: bool
    compilation_errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    compiled_size_bytes: int = 0
    compilation_time_ms: float = 0.0


@dataclass
class DeploymentResult:
    """Result of bundle deployment to OPA."""
    
    bundle_id: str
    deployment_id: str
    success: bool
    deployed_at: Optional[datetime] = None
    rollback_available: bool = False
    previous_bundle_id: Optional[str] = None
    deployment_time_ms: float = 0.0
    error_message: Optional[str] = None


class RegoValidator:
    """Validates Rego rules for syntax and best practices."""
    
    def __init__(self):
        self.validation_rules = {
            "package_declaration": r"^package\s+[\w\.]+",
            "default_deny": r"default\s+(allow|deny)\s*=\s*(false|true)",
            "constitutional_hash": CONSTITUTIONAL_HASH,
            "input_validation": r"input\.",
            "proper_braces": None  # Custom validation
        }
    
    async def validate_rego_rule(self, rule_content: str, rule_id: str) -> Dict[str, Any]:
        """Validate a single Rego rule."""
        validation_result = {
            "rule_id": rule_id,
            "is_valid": True,
            "errors": [],
            "warnings": [],
            "score": 0.0,
            "constitutional_compliance": False
        }
        
        try:
            # Check package declaration
            if not any(line.strip().startswith("package ") for line in rule_content.split('\n')):
                validation_result["errors"].append("Missing package declaration")
                validation_result["is_valid"] = False
            else:
                validation_result["score"] += 0.2
            
            # Check for default policy
            if "default " in rule_content:
                validation_result["score"] += 0.2
            else:
                validation_result["warnings"].append("Consider adding default policy")
            
            # Check constitutional compliance
            if CONSTITUTIONAL_HASH in rule_content:
                validation_result["constitutional_compliance"] = True
                validation_result["score"] += 0.3
            else:
                validation_result["errors"].append("Missing constitutional hash validation")
                validation_result["is_valid"] = False
            
            # Check input validation
            if "input." in rule_content:
                validation_result["score"] += 0.2
            else:
                validation_result["warnings"].append("No input validation detected")
            
            # Check brace matching
            open_braces = rule_content.count('{')
            close_braces = rule_content.count('}')
            if open_braces != close_braces:
                validation_result["errors"].append("Mismatched braces")
                validation_result["is_valid"] = False
            else:
                validation_result["score"] += 0.1
            
            # Final score adjustment
            if validation_result["is_valid"] and len(validation_result["errors"]) == 0:
                validation_result["score"] = min(validation_result["score"], 1.0)
            else:
                validation_result["score"] = max(validation_result["score"] - 0.5, 0.0)
            
        except Exception as e:
            validation_result["is_valid"] = False
            validation_result["errors"].append(f"Validation exception: {str(e)}")
            validation_result["score"] = 0.0
        
        return validation_result
    
    async def validate_bundle(self, rules: List[Tuple[str, str]]) -> Dict[str, Any]:
        """Validate a complete bundle of rules."""
        bundle_validation = {
            "is_valid": True,
            "total_rules": len(rules),
            "valid_rules": 0,
            "invalid_rules": 0,
            "rule_validations": [],
            "bundle_errors": [],
            "overall_score": 0.0
        }
        
        total_score = 0.0
        
        for rule_id, rule_content in rules:
            rule_validation = await self.validate_rego_rule(rule_content, rule_id)
            bundle_validation["rule_validations"].append(rule_validation)
            
            if rule_validation["is_valid"]:
                bundle_validation["valid_rules"] += 1
            else:
                bundle_validation["invalid_rules"] += 1
                bundle_validation["is_valid"] = False
            
            total_score += rule_validation["score"]
        
        # Calculate overall score
        if bundle_validation["total_rules"] > 0:
            bundle_validation["overall_score"] = total_score / bundle_validation["total_rules"]
        
        # Check for package conflicts
        packages = set()
        for rule_id, rule_content in rules:
            for line in rule_content.split('\n'):
                if line.strip().startswith("package "):
                    package_name = line.strip().split()[1]
                    if package_name in packages:
                        bundle_validation["bundle_errors"].append(f"Duplicate package: {package_name}")
                        bundle_validation["is_valid"] = False
                    packages.add(package_name)
        
        return bundle_validation


class OPABundleManager:
    """Manages OPA bundle compilation, validation, and deployment."""
    
    def __init__(self, opa_client: Optional[OPAClient] = None):
        self.opa_client = opa_client
        self.validator = RegoValidator()
        self.bundle_storage_path = Path("./opa_bundles")
        self.bundle_storage_path.mkdir(exist_ok=True)
        
        self.metrics = {
            "bundles_created": 0,
            "bundles_deployed": 0,
            "deployment_failures": 0,
            "validation_failures": 0,
            "avg_compilation_time_ms": 0.0,
            "avg_deployment_time_ms": 0.0,
            "constitutional_hash": CONSTITUTIONAL_HASH
        }
        
        logger.info("OPA Bundle Manager initialized")
    
    async def initialize(self):
        """Initialize the bundle manager."""
        if not self.opa_client:
            self.opa_client = await get_opa_client()
        
        # Ensure storage directory exists
        self.bundle_storage_path.mkdir(exist_ok=True)
        
        logger.info("OPA Bundle Manager initialization complete")
    
    async def compile_rag_rules_to_bundle(
        self,
        rag_results: List[RegoRuleResult],
        bundle_name: str = None,
        bundle_version: str = None
    ) -> Tuple[BundleMetadata, List[CompilationResult]]:
        """Compile RAG-generated rules into an OPA bundle."""
        if not self.opa_client:
            await self.initialize()
        
        start_time = time.time()
        
        # Generate bundle metadata
        bundle_id = f"rag-bundle-{int(time.time())}-{str(uuid4())[:8]}"
        bundle_name = bundle_name or f"rag-generated-{int(time.time())}"
        bundle_version = bundle_version or f"v{int(time.time())}"
        
        source_principles = []
        for result in rag_results:
            source_principles.extend(result.source_principles)
        
        metadata = BundleMetadata(
            bundle_id=bundle_id,
            name=bundle_name,
            version=bundle_version,
            created_at=datetime.now(timezone.utc),
            rules_count=len(rag_results),
            source_principles=list(set(source_principles))
        )
        
        # Compile individual rules
        compilation_results = []
        valid_rules = []
        
        for rag_result in rag_results:
            compile_start = time.time()
            
            # Validate rule
            validation_result = await self.validator.validate_rego_rule(
                rag_result.rule_content, rag_result.rule_id
            )
            
            compilation_result = CompilationResult(
                rule_id=rag_result.rule_id,
                compiled_successfully=validation_result["is_valid"],
                compilation_errors=validation_result["errors"],
                warnings=validation_result["warnings"],
                compiled_size_bytes=len(rag_result.rule_content.encode('utf-8')),
                compilation_time_ms=(time.time() - compile_start) * 1000
            )
            
            compilation_results.append(compilation_result)
            
            if compilation_result.compiled_successfully:
                valid_rules.append((rag_result.rule_id, rag_result.rule_content))
        
        # Validate complete bundle
        bundle_validation = await self.validator.validate_bundle(valid_rules)
        metadata.validation_results = bundle_validation
        
        # Update metrics
        total_compilation_time = (time.time() - start_time) * 1000
        self._update_compilation_metrics(total_compilation_time, len(compilation_results))
        
        if not bundle_validation["is_valid"]:
            self.metrics["validation_failures"] += 1
            logger.error(f"Bundle validation failed for {bundle_id}")
        else:
            self.metrics["bundles_created"] += 1
            logger.info(f"Bundle {bundle_id} compiled successfully with {len(valid_rules)} valid rules")
        
        return metadata, compilation_results
    
    async def create_bundle_archive(
        self,
        metadata: BundleMetadata,
        rules: List[Tuple[str, str]]
    ) -> Path:
        """Create a bundle archive file."""
        bundle_dir = self.bundle_storage_path / metadata.bundle_id
        bundle_dir.mkdir(exist_ok=True)
        
        # Create bundle manifest
        manifest = {
            "metadata": {
                "bundle_id": metadata.bundle_id,
                "name": metadata.name,
                "version": metadata.version,
                "created_at": metadata.created_at.isoformat(),
                "constitutional_hash": CONSTITUTIONAL_HASH
            },
            "rules": [rule_id for rule_id, _ in rules],
            "validation": metadata.validation_results
        }
        
        manifest_path = bundle_dir / "manifest.json"
        async with aiofiles.open(manifest_path, 'w') as f:
            await f.write(json.dumps(manifest, indent=2))
        
        # Write individual rule files
        for rule_id, rule_content in rules:
            rule_file = bundle_dir / f"{rule_id}.rego"
            async with aiofiles.open(rule_file, 'w') as f:
                await f.write(rule_content)
        
        # Create ZIP archive
        archive_path = self.bundle_storage_path / f"{metadata.bundle_id}.tar.gz"
        
        # Use asyncio to run the compression in a thread
        await asyncio.to_thread(self._create_archive, bundle_dir, archive_path)
        
        logger.info(f"Bundle archive created: {archive_path}")
        return archive_path
    
    def _create_archive(self, source_dir: Path, archive_path: Path):
        """Create archive file (runs in thread)."""
        import tarfile
        
        with tarfile.open(archive_path, 'w:gz') as tar:
            tar.add(source_dir, arcname=source_dir.name)
    
    async def deploy_bundle_to_opa(
        self,
        metadata: BundleMetadata,
        rules: List[Tuple[str, str]],
        validate_deployment: bool = True
    ) -> DeploymentResult:
        """Deploy bundle to OPA server."""
        if not self.opa_client:
            await self.initialize()
        
        start_time = time.time()
        deployment_id = f"deploy-{int(time.time())}-{str(uuid4())[:8]}"
        
        try:
            # Prepare policy bundle for OPA
            policy_dict = {rule_id: rule_content for rule_id, rule_content in rules}
            
            bundle = PolicyBundle(
                name=metadata.name,
                policies=policy_dict,
                revision=metadata.version
            )
            
            # Deploy to OPA
            compilation_metrics = await self.opa_client.upload_policy_bundle(
                bundle, incremental=False
            )
            
            deployment_time = (time.time() - start_time) * 1000
            
            # Validate deployment if requested
            deployment_success = True
            if validate_deployment:
                deployment_success = await self._validate_deployment(metadata.bundle_id)
            
            result = DeploymentResult(
                bundle_id=metadata.bundle_id,
                deployment_id=deployment_id,
                success=deployment_success,
                deployed_at=datetime.now(timezone.utc),
                rollback_available=True,  # Assume rollback is available
                deployment_time_ms=deployment_time
            )
            
            # Update metrics
            if deployment_success:
                self.metrics["bundles_deployed"] += 1
                metadata.deployment_status = "deployed"
                logger.info(f"Bundle {metadata.bundle_id} deployed successfully")
            else:
                self.metrics["deployment_failures"] += 1
                metadata.deployment_status = "failed"
                result.error_message = "Deployment validation failed"
                logger.error(f"Bundle {metadata.bundle_id} deployment failed validation")
            
            self._update_deployment_metrics(deployment_time)
            
            return result
            
        except Exception as e:
            self.metrics["deployment_failures"] += 1
            metadata.deployment_status = "failed"
            
            error_result = DeploymentResult(
                bundle_id=metadata.bundle_id,
                deployment_id=deployment_id,
                success=False,
                deployment_time_ms=(time.time() - start_time) * 1000,
                error_message=str(e)
            )
            
            logger.error(f"Bundle deployment failed: {e}")
            return error_result
    
    async def _validate_deployment(self, bundle_id: str) -> bool:
        """Validate that bundle was deployed successfully."""
        try:
            # Check OPA server health
            health_check = await self.opa_client.health_check()
            if not health_check:
                return False
            
            # Try a simple policy evaluation to ensure rules are loaded
            test_input = {
                "constitutional_hash": CONSTITUTIONAL_HASH,
                "test_validation": True
            }
            
            # This is a basic validation - in production you'd want more comprehensive checks
            server_info = await self.opa_client.get_server_info()
            return "version" in server_info
            
        except Exception as e:
            logger.error(f"Deployment validation failed: {e}")
            return False
    
    def _update_compilation_metrics(self, compilation_time_ms: float, rules_count: int):
        """Update compilation metrics."""
        current_avg = self.metrics["avg_compilation_time_ms"]
        total_bundles = self.metrics["bundles_created"]
        
        if total_bundles > 0:
            self.metrics["avg_compilation_time_ms"] = (
                (current_avg * (total_bundles - 1) + compilation_time_ms) / total_bundles
            )
        else:
            self.metrics["avg_compilation_time_ms"] = compilation_time_ms
    
    def _update_deployment_metrics(self, deployment_time_ms: float):
        """Update deployment metrics."""
        current_avg = self.metrics["avg_deployment_time_ms"]
        total_deployments = self.metrics["bundles_deployed"]
        
        if total_deployments > 0:
            self.metrics["avg_deployment_time_ms"] = (
                (current_avg * (total_deployments - 1) + deployment_time_ms) / total_deployments
            )
        else:
            self.metrics["avg_deployment_time_ms"] = deployment_time_ms
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get bundle manager metrics."""
        success_rate = 0.0
        total_attempts = self.metrics["bundles_deployed"] + self.metrics["deployment_failures"]
        if total_attempts > 0:
            success_rate = self.metrics["bundles_deployed"] / total_attempts
        
        return {
            **self.metrics,
            "deployment_success_rate": success_rate,
            "bundle_storage_path": str(self.bundle_storage_path),
            "validator_available": self.validator is not None,
            "opa_client_available": self.opa_client is not None
        }
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform health check of bundle manager."""
        health_status = {
            "status": "healthy",
            "bundle_manager_initialized": self.opa_client is not None,
            "storage_accessible": self.bundle_storage_path.exists(),
            "constitutional_hash": CONSTITUTIONAL_HASH,
            "timestamp": time.time()
        }
        
        try:
            if self.opa_client:
                opa_health = await self.opa_client.health_check()
                health_status["opa_server_healthy"] = opa_health
                
                if not opa_health:
                    health_status["status"] = "degraded"
            else:
                health_status["status"] = "not_initialized"
                
        except Exception as e:
            health_status["status"] = "unhealthy"
            health_status["error"] = str(e)
            logger.error(f"Bundle manager health check failed: {e}")
        
        return health_status


# Global instance for service integration
_bundle_manager: Optional[OPABundleManager] = None


async def get_bundle_manager() -> OPABundleManager:
    """Get or create global bundle manager instance."""
    global _bundle_manager
    
    if _bundle_manager is None:
        _bundle_manager = OPABundleManager()
        await _bundle_manager.initialize()
    
    return _bundle_manager
