# backend/gs_service/app/schemas.py
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field, field_validator
from datetime import datetime

# Schemas for Policy Templates
class GSTemplateBase(BaseModel):
    name: str = Field(..., min_length=3, description="Unique name for the policy template")
    description: Optional[str] = None
    default_content: str = Field(..., description="The Datalog (or other P-IR) template string for the policy body")
    # JSON schema describing the expected structure and types of customization_parameters
    parameters_schema: Optional[Dict[str, Any]] = Field(None, description="JSON schema for customizable parameters")

class GSTemplateCreate(GSTemplateBase):
    pass

class GSTemplateUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    default_content: Optional[str] = None
    parameters_schema: Optional[Dict[str, Any]] = None
    # Version increment should be handled by backend logic

class GSTemplateResponse(GSTemplateBase):
    id: int
    version: int
    created_at: datetime
    updated_at: datetime
    created_by_user_id: Optional[int] = None

    class Config:
        from_attributes = True # Pydantic V2 alias for orm_mode
        
class GSTemplateListResponse(BaseModel):
    templates: List[GSTemplateResponse]
    total: int

# Schemas for Policies (instantiated from templates or created directly)
class GSPolicyBase(BaseModel):
    name: str = Field(..., min_length=3, description="Unique name for the policy instance")
    description: Optional[str] = None
    # Content is the P-IR/Datalog, can be raw or instantiated from a template
    content: str = Field(..., description="The policy content (e.g., Datalog rules, Rego)")
    status: str = Field(default="draft_pending_synthesis", description="Lifecycle status of the policy instance")
    template_id: Optional[int] = Field(None, description="ID of the PolicyTemplate used, if any")
    # Parameters used to customize the template to produce this policy instance's content
    customization_parameters: Optional[Dict[str, Any]] = Field(None, description="Parameters used for template customization")
    source_principle_ids: Optional[List[int]] = Field(None, description="Link to AC principles informing this policy")


class GSPolicyCreate(GSPolicyBase):
    # If creating from template, content might be omitted and generated by backend
    # Or content can be provided directly if not using a template
    content: Optional[str] = None # Make content optional if template_id is provided

    @field_validator('content')
    @classmethod
    def check_content_or_template(cls, v, info):
        values = info.data if hasattr(info, 'data') else {}
        if (info.data if hasattr(info, "data") else {}).get('template_id') is None and v is None:
            raise ValueError('Either template_id or content must be provided')
        # If template_id is provided, content might be generated, so it can be None initially.
        # If content is provided, it implies direct policy creation.
        # Deciding on precedence or error if both are given:
        # if (info.data if hasattr(info, "data") else {}).get('template_id') is not None and v is not None:
        #     raise ValueError('Provide either template_id (with parameters) or direct content, not both.')
        return v


class GSPolicyUpdateRequest(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    content: Optional[str] = None
    status: Optional[str] = None
    customization_parameters: Optional[Dict[str, Any]] = None
    source_principle_ids: Optional[List[int]] = None
    # Version increment handled by backend

class GSPolicyResponse(GSPolicyBase):
    id: int
    version: int
    created_at: datetime
    updated_at: datetime
    created_by_user_id: Optional[int] = None
    # Could also include template details if fetched with a join
    # template: Optional[GSTemplateResponse] = None 

    class Config:
        from_attributes = True # Pydantic V2 alias for orm_mode

class GSPolicyListResponse(BaseModel):
    policies: List[GSPolicyResponse]
    total: int
    
# Re-define synthesis request if it now takes a GSPolicy ID
class SynthesisRequest(BaseModel): # This was already in gs_service/app/schemas.py (or should be)
    # If synthesis now operates on a pre-created Policy instance:
    policy_id: Optional[int] = Field(None, description="ID of the GSPolicy instance to synthesize into Datalog rules. If provided, principles might be ignored or used as context.")
    # Keep principles if direct synthesis from principles is still supported
    principles: Optional[List[Dict[str, int]]] = Field(None, description="List of principles (e.g., [{'id': 1}]) to synthesize rules from, if not using a policy_id.")
    target_context: Optional[str] = Field(None, description="Optional context for synthesis") # Added from issue

    @field_validator('principles')
    @classmethod
    def check_policy_id_or_principles(cls, v, info):
        values = info.data if hasattr(info, 'data') else {}
        if (info.data if hasattr(info, "data") else {}).get('policy_id') is None and v is None:
            raise ValueError('Either policy_id or principles must be provided for synthesis')
        return v

# The following schemas might have been in the file before and should be preserved if they don't conflict.
# Or, if the file should ONLY contain the schemas above, then this part can be omitted.
# For now, let's assume the issue means to ADD/UPDATE, so existing non-conflicting schemas can remain.
# However, the subtask report implied a full replacement. Given the discrepancy, a full replacement with
# the content explicitly listed in section 3.a of the issue is safer.

class ACPrinciple(BaseModel): # From original SynthesisRequest, may or may not be needed elsewhere
    id: int
    name: str
    description: Optional[str] = None
    content: str
    category: Optional[str] = None
    related_principles: Optional[List[int]] = None
    class Config:
        from_attributes = True

class GeneratedRuleInfo(BaseModel):
    rule_content: str
    source_principle_ids: List[int] # Changed from Optional[List[int]] to List[int] as per issue context
    # stored_rule_id: Optional[int] = None # This was in an example, might be needed for response

class SynthesisResponse(BaseModel):
    generated_rules: List[GeneratedRuleInfo]
    message: str
    overall_synthesis_status: str # e.g., "success", "partial_failure", "failure"
    error_prediction: Optional[Dict[str, Any]] = Field(None, description="Error prediction and risk assessment metadata")
    # detailed_statuses: Optional[List[Dict[str, Any]]] = None # For per-principle status if needed

# Added for Structured LLM Interaction and Rule Assembly as per issue #ISSUE_ID
# (Replace #ISSUE_ID with a relevant identifier if available, otherwise omit this line)

class LLMInterpretationInput(BaseModel):
    principle_id: int
    principle_content: str
    target_context: Optional[str] = None
    # Example: Provide a schema of available Datalog predicates
    datalog_predicate_schema: Optional[Dict[str, str]] = None 
    few_shot_examples: Optional[List[Dict[str, str]]] = None

class LLMSuggestedAtom(BaseModel):
    predicate_name: str
    arguments: List[str] # Variables or constants
    is_negated: Optional[bool] = False

class LLMSuggestedRule(BaseModel):
    head: LLMSuggestedAtom
    body: List[LLMSuggestedAtom]
    explanation: Optional[str] = None # LLM's reasoning
    confidence: Optional[float] = None

class LLMStructuredOutput(BaseModel):
    interpretations: List[LLMSuggestedRule]
    raw_llm_response: Optional[str] = None

# Constitutional Synthesis Schemas for Phase 1

class ConstitutionalSynthesisInput(BaseModel):
    """Input for constitutional synthesis with AC principles integration."""
    context: str = Field(..., description="Target context for policy synthesis")
    category: Optional[str] = Field(None, description="Optional category filter for principles")
    synthesis_request: str = Field(..., description="Specific synthesis request description")
    target_format: str = Field("datalog", description="Target format for generated policies")
    auth_token: Optional[str] = Field(None, description="Authentication token for AC service")

class ConstitutionalComplianceInfo(BaseModel):
    """Information about constitutional compliance of generated policies."""
    principle_id: int = Field(..., description="ID of the principle that influenced this rule")
    principle_name: str = Field(..., description="Name of the principle")
    priority_weight: Optional[float] = Field(None, description="Priority weight of the principle")
    influence_level: str = Field(..., description="Level of influence (CRITICAL, HIGH, MEDIUM, LOW)")
    compliance_score: float = Field(..., ge=0.0, le=1.0, description="Compliance score (0.0 to 1.0)")

class ConstitutionallyCompliantRule(BaseModel):
    """A rule generated with constitutional compliance information."""
    rule_content: str = Field(..., description="The generated rule content")
    rule_format: str = Field(..., description="Format of the rule (datalog, rego, etc.)")
    constitutional_compliance: List[ConstitutionalComplianceInfo] = Field(
        ..., description="Constitutional compliance information"
    )
    explanation: str = Field(..., description="Explanation of how the rule satisfies constitutional principles")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence in the rule generation")

class ConstitutionalSynthesisOutput(BaseModel):
    """Output from constitutional synthesis process."""
    context: str = Field(..., description="Target context for synthesis")
    generated_rules: List[ConstitutionallyCompliantRule] = Field(..., description="Generated constitutionally compliant rules")
    constitutional_context: Dict[str, Any] = Field(..., description="Constitutional context used for synthesis")
    synthesis_metadata: Dict[str, Any] = Field(..., description="Metadata about the synthesis process")
    raw_llm_response: str = Field(..., description="Raw LLM response for debugging")

# PolicyRule Schemas for Integrity Service Integration

class PolicyRuleBase(BaseModel):
    rule_content: str = Field(..., description="Datalog rule content")
    source_principle_ids: Optional[List[int]] = Field(None, description="List of AC principle IDs it's derived from")

class PolicyRuleCreate(PolicyRuleBase):
    # version will be defaulted in CRUD or model
    # verification_status will be defaulted
    pass

class PolicyRule(PolicyRuleBase): # For API responses
    id: int
    version: int
    verification_status: str
    verified_at: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

# FV Service Integration Schemas

class FVPolicyRuleRef(BaseModel):
    id: int # ID of the policy rule in Integrity Service

class FVVerificationRequest(BaseModel):
    policy_rule_refs: List[FVPolicyRuleRef] = Field(..., description="References to policy rules to be verified.")

class FVVerificationResult(BaseModel):
    policy_rule_id: int
    status: str # e.g., "verified", "failed", "error"
    message: Optional[str] = None
    counter_example: Optional[str] = None

class FVVerificationResponse(BaseModel):
    results: List[FVVerificationResult]
    overall_status: str # e.g., "all_verified", "some_failed", "error"
    summary_message: Optional[str] = None

# End of added schemas

# Phase 2: AlphaEvolve Integration Schemas

class ECProposal(BaseModel):
    """Evolutionary Computation proposal for governance evaluation"""
    proposal_id: str = Field(..., description="Unique identifier for the EC proposal")
    solution_code: str = Field(..., description="Generated solution code to evaluate")
    generation: int = Field(..., description="Generation number in EC process")
    parent_ids: List[str] = Field(default_factory=list, description="Parent solution IDs")
    fitness_context: Dict[str, Any] = Field(..., description="Context for fitness evaluation")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional EC metadata")

class ECGovernanceDecision(BaseModel):
    """Governance decision for an EC proposal"""
    proposal_id: str = Field(..., description="ID of the evaluated proposal")
    decision: str = Field(..., description="Governance decision (allow/deny/modify)")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence in the decision")
    violated_principles: List[str] = Field(default_factory=list, description="IDs of violated principles")
    governance_penalty: float = Field(0.0, description="Penalty score for fitness function")
    explanation: str = Field(..., description="Human-readable explanation of decision")
    enforcement_actions: List[str] = Field(default_factory=list, description="Required enforcement actions")
    timestamp: datetime = Field(..., description="Decision timestamp")

class ECConstitutionalPromptingInput(BaseModel):
    """Input for constitutional prompting in EC context"""
    ec_context: str = Field(..., description="Evolutionary computation context")
    current_population: List[ECProposal] = Field(..., description="Current EC population")
    optimization_objective: str = Field(..., description="EC optimization objective")
    constitutional_constraints: List[str] = Field(..., description="Constitutional constraints to apply")
    generation_guidance: bool = Field(True, description="Whether to provide generation guidance")

class ECConstitutionalPromptingOutput(BaseModel):
    """Output from constitutional prompting for EC"""
    prompting_id: str = Field(..., description="Unique identifier for this prompting session")
    constitutional_guidance: str = Field(..., description="Constitutional guidance for EC system")
    fitness_modifications: Dict[str, Any] = Field(..., description="Suggested fitness function modifications")
    operator_constraints: List[str] = Field(..., description="Constraints for EC operators")
    population_filters: List[str] = Field(..., description="Population filtering rules")
    synthesis_metadata: Dict[str, Any] = Field(..., description="Metadata about the prompting process")

class ECGovernanceRequest(BaseModel):
    """Request for EC governance evaluation"""
    proposals: List[ECProposal] = Field(..., description="EC proposals to evaluate")
    context: str = Field(..., description="Governance context")
    real_time: bool = Field(True, description="Whether this is a real-time evaluation")
    batch_size: Optional[int] = Field(None, description="Batch size for processing")
    priority: str = Field("normal", description="Processing priority (low/normal/high/critical)")

class ECGovernanceResponse(BaseModel):
    """Response from EC governance evaluation"""
    evaluation_id: str = Field(..., description="Unique identifier for this evaluation")
    decisions: List[ECGovernanceDecision] = Field(..., description="Governance decisions for each proposal")
    batch_summary: Dict[str, Any] = Field(..., description="Summary statistics for the batch")
    processing_time_ms: float = Field(..., description="Processing time in milliseconds")
    constitutional_compliance_rate: float = Field(..., description="Overall compliance rate")
    recommendations: List[str] = Field(default_factory=list, description="Recommendations for EC system")
