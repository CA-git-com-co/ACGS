# backend/gs_service/app/schemas.py
from datetime import datetime
from typing import Any

from pydantic import BaseModel, Field, field_validator

# Constitutional compliance hash for ACGS
CONSTITUTIONAL_HASH = "cdd01ef066bc6cf2"



# Schemas for Policy Templates
class GSTemplateBase(BaseModel):
    name: str = Field(
        ..., min_length=3, description="Unique name for the policy template"
    )
    description: str | None = None
    default_content: str = Field(
        ...,
        description="The Datalog (or other P-IR) template string for the policy body",
    )
    # JSON schema describing the expected structure and types of customization_parameters
    parameters_schema: dict[str, Any] | None = Field(
        None, description="JSON schema for customizable parameters"
    )


class GSTemplateCreate(GSTemplateBase):
    pass


class GSTemplateUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    default_content: str | None = None
    parameters_schema: dict[str, Any] | None = None
    # Version increment should be handled by backend logic


class GSTemplateResponse(GSTemplateBase):
    id: int
    version: int
    created_at: datetime
    updated_at: datetime
    created_by_user_id: int | None = None

    class Config:
        from_attributes = True  # Pydantic V2 alias for orm_mode


class GSTemplateListResponse(BaseModel):
    templates: list[GSTemplateResponse]
    total: int


# Schemas for Policies (instantiated from templates or created directly)
class GSPolicyBase(BaseModel):
    name: str = Field(
        ..., min_length=3, description="Unique name for the policy instance"
    )
    description: str | None = None
    # Content is the P-IR/Datalog, can be raw or instantiated from a template
    content: str = Field(
        ..., description="The policy content (e.g., Datalog rules, Rego)"
    )
    status: str = Field(
        default="draft_pending_synthesis",
        description="Lifecycle status of the policy instance",
    )
    template_id: int | None = Field(
        None, description="ID of the PolicyTemplate used, if any"
    )
    # Parameters used to customize the template to produce this policy instance's content
    customization_parameters: dict[str, Any] | None = Field(
        None, description="Parameters used for template customization"
    )
    source_principle_ids: list[int] | None = Field(
        None, description="Link to AC principles informing this policy"
    )


class GSPolicyCreate(GSPolicyBase):
    # If creating from template, content might be omitted and generated by backend
    # Or content can be provided directly if not using a template
    content: str | None = None  # Make content optional if template_id is provided

    @field_validator("content")
    @classmethod
    def check_content_or_template(cls, v, info):
        # requires: Valid input parameters
        # ensures: Correct function execution
        # sha256: func_hash
        info.data if hasattr(info, "data") else {}
        if (info.data if hasattr(info, "data") else {}).get(
            "template_id"
        ) is None and v is None:
            raise ValueError("Either template_id or content must be provided")
        # If template_id is provided, content might be generated, so it can be None initially.
        # If content is provided, it implies direct policy creation.
        # Deciding on precedence or error if both are given:
        # if (info.data if hasattr(info, "data") else {}).get('template_id') is not None and v is not None:
        #     raise ValueError('Provide either template_id (with parameters) or direct content, not both.')
        return v


class GSPolicyUpdateRequest(BaseModel):
    name: str | None = None
    description: str | None = None
    content: str | None = None
    status: str | None = None
    customization_parameters: dict[str, Any] | None = None
    source_principle_ids: list[int] | None = None
    # Version increment handled by backend


class GSPolicyResponse(GSPolicyBase):
    id: int
    version: int
    created_at: datetime
    updated_at: datetime
    created_by_user_id: int | None = None
    # Could also include template details if fetched with a join
    # template: Optional[GSTemplateResponse] = None

    class Config:
        from_attributes = True  # Pydantic V2 alias for orm_mode


class GSPolicyListResponse(BaseModel):
    policies: list[GSPolicyResponse]
    total: int


# Re-define synthesis request if it now takes a GSPolicy ID
class SynthesisRequest(
    BaseModel
):  # This was already in gs_service/app/schemas.py (or should be)
    # If synthesis now operates on a pre-created Policy instance:
    policy_id: int | None = Field(
        None,
        description="ID of the GSPolicy instance to synthesize into Datalog rules. If provided, principles might be ignored or used as context.",
    )
    # Keep principles if direct synthesis from principles is still supported
    principles: list[dict[str, int]] | None = Field(
        None,
        description="List of principles (e.g., [{'id': 1}]) to synthesize rules from, if not using a policy_id.",
    )
    target_context: str | None = Field(
        None, description="Optional context for synthesis"
    )  # Added from issue

    @field_validator("principles")
    @classmethod
    def check_policy_id_or_principles(cls, v, info):
        # requires: Valid input parameters
        # ensures: Correct function execution
        # sha256: func_hash
        info.data if hasattr(info, "data") else {}
        if (info.data if hasattr(info, "data") else {}).get(
            "policy_id"
        ) is None and v is None:
            raise ValueError(
                "Either policy_id or principles must be provided for synthesis"
            )
        return v


# The following schemas might have been in the file before and should be preserved if they don't conflict.
# Or, if the file should ONLY contain the schemas above, then this part can be omitted.
# For now, let's assume the issue means to ADD/UPDATE, so existing non-conflicting schemas can remain.
# However, the subtask report implied a full replacement. Given the discrepancy, a full replacement with
# the content explicitly listed in section 3.a of the issue is safer.


class ACPrinciple(
    BaseModel
):  # From original SynthesisRequest, may or may not be needed elsewhere
    id: int
    name: str
    description: str | None = None
    content: str
    category: str | None = None
    related_principles: list[int] | None = None

    class Config:
        from_attributes = True


class GeneratedRuleInfo(BaseModel):
    rule_content: str
    source_principle_ids: list[
        int
    ]  # Changed from Optional[List[int]] to List[int] as per issue context
    # stored_rule_id: Optional[int] = None # This was in an example, might be needed for response


class SynthesisResponse(BaseModel):
    generated_rules: list[GeneratedRuleInfo]
    message: str
    overall_synthesis_status: str  # e.g., "success", "partial_failure", "failure"
    error_prediction: dict[str, Any] | None = Field(
        None, description="Error prediction and risk assessment metadata"
    )
    # detailed_statuses: Optional[List[Dict[str, Any]]] = None # For per-principle status if needed


# Added for Structured LLM Interaction and Rule Assembly as per issue #ISSUE_ID
# (Replace #ISSUE_ID with a relevant identifier if available, otherwise omit this line)


class LLMInterpretationInput(BaseModel):
    principle_id: int
    principle_content: str
    target_context: str | None = None
    # Example: Provide a schema of available Datalog predicates
    datalog_predicate_schema: dict[str, str] | None = None
    few_shot_examples: list[dict[str, str]] | None = None


class LLMSuggestedAtom(BaseModel):
    predicate_name: str
    arguments: list[str]  # Variables or constants
    is_negated: bool | None = False


class LLMSuggestedRule(BaseModel):
    head: LLMSuggestedAtom
    body: list[LLMSuggestedAtom]
    explanation: str | None = None  # LLM's reasoning
    confidence: float | None = None


class LLMStructuredOutput(BaseModel):
    interpretations: list[LLMSuggestedRule]
    raw_llm_response: str | None = None


# Constitutional Synthesis Schemas for Phase 1


class ConstitutionalSynthesisInput(BaseModel):
    """Input for constitutional synthesis with AC principles integration."""

    context: str = Field(..., description="Target context for policy synthesis")
    category: str | None = Field(
        None, description="Optional category filter for principles"
    )
    synthesis_request: str = Field(
        ..., description="Specific synthesis request description"
    )
    target_format: str = Field(
        "datalog", description="Target format for generated policies"
    )
    auth_token: str | None = Field(
        None, description="Authentication token for AC service"
    )


class ConstitutionalComplianceInfo(BaseModel):
    """Information about constitutional compliance of generated policies."""

    principle_id: int = Field(
        ..., description="ID of the principle that influenced this rule"
    )
    principle_name: str = Field(..., description="Name of the principle")
    priority_weight: float | None = Field(
        None, description="Priority weight of the principle"
    )
    influence_level: str = Field(
        ..., description="Level of influence (CRITICAL, HIGH, MEDIUM, LOW)"
    )
    compliance_score: float = Field(
        ..., ge=0.0, le=1.0, description="Compliance score (0.0 to 1.0)"
    )


class ConstitutionallyCompliantRule(BaseModel):
    """A rule generated with constitutional compliance information."""

    rule_content: str = Field(..., description="The generated rule content")
    rule_format: str = Field(
        ..., description="Format of the rule (datalog, rego, etc.)"
    )
    constitutional_compliance: list[ConstitutionalComplianceInfo] = Field(
        ..., description="Constitutional compliance information"
    )
    explanation: str = Field(
        ...,
        description="Explanation of how the rule satisfies constitutional principles",
    )
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Confidence in the rule generation"
    )


class ConstitutionalSynthesisOutput(BaseModel):
    """Output from constitutional synthesis process."""

    context: str = Field(..., description="Target context for synthesis")
    generated_rules: list[ConstitutionallyCompliantRule] = Field(
        ..., description="Generated constitutionally compliant rules"
    )
    constitutional_context: dict[str, Any] = Field(
        ..., description="Constitutional context used for synthesis"
    )
    synthesis_metadata: dict[str, Any] = Field(
        ..., description="Metadata about the synthesis process"
    )
    raw_llm_response: str = Field(..., description="Raw LLM response for debugging")


# PolicyRule Schemas for Integrity Service Integration


class PolicyRuleBase(BaseModel):
    rule_content: str = Field(..., description="Datalog rule content")
    source_principle_ids: list[int] | None = Field(
        None, description="List of AC principle IDs it's derived from"
    )


class PolicyRuleCreate(PolicyRuleBase):
    # version will be defaulted in CRUD or model
    # verification_status will be defaulted
    pass


class PolicyRule(PolicyRuleBase):  # For API responses
    id: int
    version: int
    verification_status: str
    verified_at: datetime | None = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# FV Service Integration Schemas


class FVPolicyRuleRef(BaseModel):
    id: int  # ID of the policy rule in Integrity Service


class FVVerificationRequest(BaseModel):
    policy_rule_refs: list[FVPolicyRuleRef] = Field(
        ..., description="References to policy rules to be verified."
    )


class FVVerificationResult(BaseModel):
    policy_rule_id: int
    status: str  # e.g., "verified", "failed", "error"
    message: str | None = None
    counter_example: str | None = None


class FVVerificationResponse(BaseModel):
    results: list[FVVerificationResult]
    overall_status: str  # e.g., "all_verified", "some_failed", "error"
    summary_message: str | None = None


# End of added schemas

# Phase 2: AlphaEvolve Integration Schemas


class ECProposal(BaseModel):
    """Evolutionary Computation proposal for governance evaluation"""

    proposal_id: str = Field(..., description="Unique identifier for the EC proposal")
    solution_code: str = Field(..., description="Generated solution code to evaluate")
    generation: int = Field(..., description="Generation number in EC process")
    parent_ids: list[str] = Field(
        default_factory=list, description="Parent solution IDs"
    )
    fitness_context: dict[str, Any] = Field(
        ..., description="Context for fitness evaluation"
    )
    metadata: dict[str, Any] | None = Field(None, description="Additional EC metadata")


class ECGovernanceDecision(BaseModel):
    """Governance decision for an EC proposal"""

    proposal_id: str = Field(..., description="ID of the evaluated proposal")
    decision: str = Field(..., description="Governance decision (allow/deny/modify)")
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Confidence in the decision"
    )
    violated_principles: list[str] = Field(
        default_factory=list, description="IDs of violated principles"
    )
    governance_penalty: float = Field(
        0.0, description="Penalty score for fitness function"
    )
    explanation: str = Field(..., description="Human-readable explanation of decision")
    enforcement_actions: list[str] = Field(
        default_factory=list, description="Required enforcement actions"
    )
    timestamp: datetime = Field(..., description="Decision timestamp")


class ECConstitutionalPromptingInput(BaseModel):
    """Input for constitutional prompting in EC context"""

    ec_context: str = Field(..., description="Evolutionary computation context")
    current_population: list[ECProposal] = Field(
        ..., description="Current EC population"
    )
    optimization_objective: str = Field(..., description="EC optimization objective")
    constitutional_constraints: list[str] = Field(
        ..., description="Constitutional constraints to apply"
    )
    generation_guidance: bool = Field(
        True, description="Whether to provide generation guidance"
    )


class ECConstitutionalPromptingOutput(BaseModel):
    """Output from constitutional prompting for EC"""

    prompting_id: str = Field(
        ..., description="Unique identifier for this prompting session"
    )
    constitutional_guidance: str = Field(
        ..., description="Constitutional guidance for EC system"
    )
    fitness_modifications: dict[str, Any] = Field(
        ..., description="Suggested fitness function modifications"
    )
    operator_constraints: list[str] = Field(
        ..., description="Constraints for EC operators"
    )
    population_filters: list[str] = Field(..., description="Population filtering rules")
    synthesis_metadata: dict[str, Any] = Field(
        ..., description="Metadata about the prompting process"
    )


class ECGovernanceRequest(BaseModel):
    """Request for EC governance evaluation"""

    proposals: list[ECProposal] = Field(..., description="EC proposals to evaluate")
    context: str = Field(..., description="Governance context")
    real_time: bool = Field(True, description="Whether this is a real-time evaluation")
    batch_size: int | None = Field(None, description="Batch size for processing")
    priority: str = Field(
        "normal", description="Processing priority (low/normal/high/critical)"
    )


class ECGovernanceResponse(BaseModel):
    """Response from EC governance evaluation"""

    evaluation_id: str = Field(..., description="Unique identifier for this evaluation")
    decisions: list[ECGovernanceDecision] = Field(
        ..., description="Governance decisions for each proposal"
    )
    batch_summary: dict[str, Any] = Field(
        ..., description="Summary statistics for the batch"
    )
    processing_time_ms: float = Field(
        ..., description="Processing time in milliseconds"
    )
    constitutional_compliance_rate: float = Field(
        ..., description="Overall compliance rate"
    )
    recommendations: list[str] = Field(
        default_factory=list, description="Recommendations for EC system"
    )
