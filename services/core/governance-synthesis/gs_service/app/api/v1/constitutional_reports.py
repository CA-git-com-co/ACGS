"""
Constitutional Reports API

API endpoints for constitutional compliance reporting, automated report generation,
and notification management. Supports real-time dashboard integration and
human intervention escalation mechanisms.

Task 19.4: Performance Dashboard Integration - API Endpoints
"""

import logging
from datetime import datetime, timedelta, timezone
from typing import List, Optional

from app.services.constitutional_reporting_service import (
    ComplianceReport,
    ConstitutionalReportingService,
    ReportFormat,
    ReportType,
)
from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Query
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from services.shared.auth import get_current_active_user, require_admin
from services.shared.database import get_async_db
from services.shared.metrics import get_metrics
from services.shared.models import User

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/constitutional-reports", tags=["constitutional-reports"])

# Initialize services
reporting_service = ConstitutionalReportingService()
metrics = get_metrics("gs_service")


# Pydantic models for API
class ReportRequest(BaseModel):
    """Request model for generating compliance reports."""

    report_type: ReportType
    period_start: Optional[datetime] = None
    period_end: Optional[datetime] = None
    format: ReportFormat = ReportFormat.JSON
    include_trends: bool = True
    include_recommendations: bool = True


class NotificationRequest(BaseModel):
    """Request model for sending notifications."""

    report_id: str
    notification_type: str = Field(..., pattern="^(email|webhook)$")
    recipients: List[str]
    urgent: bool = False


class MetricsResponse(BaseModel):
    """Response model for constitutional monitoring metrics."""

    timestamp: datetime
    fidelity_score: float
    violation_count: int
    qec_success_rate: float
    escalation_count: int
    health_status: str


@router.get("/health")
async def get_reporting_health():
    // requires: Valid input parameters
    // ensures: Correct function execution
    // sha256: func_hash
    """Get constitutional reporting system health status."""
    try:
        health_data = {
            "status": "healthy",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "services": {
                "reporting_service": "active",
                "notification_system": "active",
                "metrics_collection": "active",
            },
            "uptime_percentage": 99.8,
            "last_report_generated": (
                datetime.now(timezone.utc) - timedelta(hours=1)
            ).isoformat(),
        }

        # Update monitoring health status
        metrics.update_monitoring_health_status("reporting_service", True)

        return health_data

    except Exception as e:
        logger.error(f"Error checking reporting health: {e}")
        metrics.update_monitoring_health_status("reporting_service", False)
        raise HTTPException(status_code=500, detail="Health check failed")


@router.get("/metrics")
async def get_constitutional_monitoring_metrics(
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Get current constitutional monitoring metrics for Prometheus scraping.

    This endpoint provides real-time metrics for dashboard integration
    and monitoring system integration.
    """
    try:
        # Collect current metrics
        current_time = datetime.now(timezone.utc)

        # Mock metrics - in production, collect from actual monitoring systems
        fidelity_score = 0.89
        violation_count = 3
        qec_success_rate = 0.857
        escalation_count = 1

        # Determine health status
        if fidelity_score >= 0.85 and violation_count <= 5:
            health_status = "healthy"
        elif fidelity_score >= 0.70 and violation_count <= 10:
            health_status = "warning"
        else:
            health_status = "critical"

        # Update Prometheus metrics
        metrics.update_constitutional_fidelity_score("overall", fidelity_score)
        metrics.update_monitoring_health_status("constitutional_monitoring", True)

        response_data = MetricsResponse(
            timestamp=current_time,
            fidelity_score=fidelity_score,
            violation_count=violation_count,
            qec_success_rate=qec_success_rate,
            escalation_count=escalation_count,
            health_status=health_status,
        )

        return response_data

    except Exception as e:
        logger.error(f"Error collecting constitutional monitoring metrics: {e}")
        metrics.record_error("metrics_collection_error", "error")
        raise HTTPException(status_code=500, detail="Failed to collect metrics")


@router.post("/generate")
async def generate_compliance_report(
    request: ReportRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Generate a constitutional compliance report.

    Supports daily, weekly, and monthly reports with trend analysis
    and automated recommendations.
    """
    try:
        start_time = datetime.now(timezone.utc)

        # Generate the report
        report = await reporting_service.generate_compliance_report(
            report_type=request.report_type,
            period_start=request.period_start,
            period_end=request.period_end,
            db=db,
        )

        # Record metrics
        generation_time = (datetime.now(timezone.utc) - start_time).total_seconds()
        metrics.record_custom_metric(
            "report_generation_duration",
            generation_time,
            {"report_type": request.report_type.value, "user_id": str(current_user.id)},
        )

        # Convert to dict for JSON response
        report_dict = {
            "report_id": report.report_id,
            "report_type": report.report_type.value,
            "generated_at": report.generated_at.isoformat(),
            "period_start": report.period_start.isoformat(),
            "period_end": report.period_end.isoformat(),
            "summary": report.summary,
            "metrics": {
                "overall_fidelity_score": report.metrics.overall_fidelity_score,
                "total_violations": report.metrics.total_violations,
                "qec_success_rate": report.metrics.qec_success_rate,
                "council_activities": report.metrics.council_activities,
            },
        }

        # Include optional sections
        if request.include_trends:
            report_dict["trends"] = [
                {
                    "metric_name": trend.metric_name,
                    "change_percentage": trend.change_percentage,
                    "trend_direction": trend.trend_direction,
                    "significance": trend.significance,
                }
                for trend in report.trends
            ]

        if request.include_recommendations:
            report_dict["recommendations"] = report.recommendations

        logger.info(f"Generated compliance report: {report.report_id}")
        return report_dict

    except Exception as e:
        logger.error(f"Error generating compliance report: {e}")
        metrics.record_error("report_generation_error", "error")
        raise HTTPException(status_code=500, detail="Failed to generate report")


@router.post("/notify")
async def send_report_notification(
    request: NotificationRequest,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(require_admin),
):
    """
    Send notification for a compliance report.

    Supports email and webhook notifications for critical compliance issues
    and regular reporting.
    """
    try:
        # Mock report retrieval - in production, retrieve from storage
        mock_report = ComplianceReport(
            report_id=request.report_id,
            report_type=ReportType.DAILY,
            generated_at=datetime.now(timezone.utc),
            period_start=datetime.now(timezone.utc) - timedelta(days=1),
            period_end=datetime.now(timezone.utc),
            metrics=None,  # Would be populated from storage
            trends=[],
            recommendations=[],
            alerts=[],
            summary="Mock report for notification testing",
        )

        # Send notification in background
        background_tasks.add_task(
            reporting_service.send_notification,
            mock_report,
            request.notification_type,
            request.recipients,
        )

        # Record metrics
        metrics.record_custom_metric(
            "notification_sent",
            1,
            {
                "notification_type": request.notification_type,
                "urgent": str(request.urgent).lower(),
                "recipient_count": len(request.recipients),
            },
        )

        return {
            "message": "Notification queued successfully",
            "report_id": request.report_id,
            "notification_type": request.notification_type,
            "recipients_count": len(request.recipients),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }

    except Exception as e:
        logger.error(f"Error sending notification: {e}")
        metrics.record_error("notification_error", "error")
        raise HTTPException(status_code=500, detail="Failed to send notification")


@router.get("/dashboard-data")
async def get_dashboard_data(
    timeframe: str = Query("1h", pattern="^(1h|6h|24h|7d|30d)$"),
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Get real-time dashboard data for constitutional compliance monitoring.

    Provides data for Grafana dashboard integration and real-time monitoring.
    """
    try:
        current_time = datetime.now(timezone.utc)

        # Calculate timeframe
        timeframe_mapping = {
            "1h": timedelta(hours=1),
            "6h": timedelta(hours=6),
            "24h": timedelta(days=1),
            "7d": timedelta(days=7),
            "30d": timedelta(days=30),
        }

        period_start = current_time - timeframe_mapping[timeframe]

        # Mock dashboard data - in production, query actual metrics
        dashboard_data = {
            "timestamp": current_time.isoformat(),
            "timeframe": timeframe,
            "period_start": period_start.isoformat(),
            "period_end": current_time.isoformat(),
            "current_metrics": {
                "fidelity_score": 0.89,
                "violation_rate": 0.12,  # violations per hour
                "qec_success_rate": 0.857,
                "escalation_rate": 0.05,  # escalations per hour
                "response_time_p95": 12.3,  # seconds
                "council_activity_score": 0.78,
            },
            "trend_indicators": {
                "fidelity_trend": "improving",
                "violation_trend": "stable",
                "qec_trend": "improving",
                "escalation_trend": "declining",
            },
            "active_alerts": [
                {
                    "id": "alert_001",
                    "severity": "medium",
                    "message": "QEC response time elevated",
                    "timestamp": (current_time - timedelta(minutes=15)).isoformat(),
                }
            ],
            "health_status": {
                "overall": "healthy",
                "components": {
                    "fidelity_monitor": "healthy",
                    "violation_detection": "healthy",
                    "qec_system": "warning",
                    "escalation_system": "healthy",
                },
            },
        }

        # Update monitoring metrics
        metrics.update_constitutional_fidelity_score("overall", 0.89)
        metrics.update_monitoring_health_status("dashboard", True)

        return dashboard_data

    except Exception as e:
        logger.error(f"Error getting dashboard data: {e}")
        metrics.record_error("dashboard_data_error", "error")
        raise HTTPException(status_code=500, detail="Failed to get dashboard data")


@router.post("/escalate")
async def escalate_critical_issue(
    issue_id: str,
    escalation_level: str = Query(..., pattern="^(low|medium|high|critical)$"),
    reason: str = Query(..., min_length=10),
    notify_council: bool = Query(False),
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(require_admin),
):
    """
    Escalate a critical constitutional compliance issue.

    Provides manual escalation capabilities for automated decisions
    with audit trail integration.
    """
    try:
        escalation_time = datetime.now(timezone.utc)

        # Record escalation
        escalation_data = {
            "escalation_id": f"esc_{int(escalation_time.timestamp())}",
            "issue_id": issue_id,
            "escalation_level": escalation_level,
            "reason": reason,
            "escalated_by": current_user.id,
            "escalated_at": escalation_time.isoformat(),
            "notify_council": notify_council,
            "status": "active",
        }

        # Record metrics
        metrics.record_violation_escalation(
            escalation_level, False
        )  # Manual escalation
        metrics.record_constitutional_council_activity("escalation_received", "active")

        # Mock notification to Constitutional Council
        if notify_council:
            logger.info(
                f"Constitutional Council notified of escalation: {escalation_data['escalation_id']}"
            )

        logger.info(f"Critical issue escalated: {issue_id} -> {escalation_level}")

        return {
            "message": "Issue escalated successfully",
            "escalation_data": escalation_data,
            "estimated_resolution_time": (
                "< 5 minutes" if escalation_level == "critical" else "< 30 minutes"
            ),
        }

    except Exception as e:
        logger.error(f"Error escalating critical issue: {e}")
        metrics.record_error("escalation_error", "error")
        raise HTTPException(status_code=500, detail="Failed to escalate issue")
